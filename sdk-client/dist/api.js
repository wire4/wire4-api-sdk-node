"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Wire4RestAPI
 * Referencia de la API de Wire4
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DepositantesApi = exports.DepositantesApiFactory = exports.DepositantesApiFp = exports.DepositantesApiFetchParamCreator = exports.CuentasDeBeneficiariosSPIDApi = exports.CuentasDeBeneficiariosSPIDApiFactory = exports.CuentasDeBeneficiariosSPIDApiFp = exports.CuentasDeBeneficiariosSPIDApiFetchParamCreator = exports.CuentasDeBeneficiariosSPEIApi = exports.CuentasDeBeneficiariosSPEIApiFactory = exports.CuentasDeBeneficiariosSPEIApiFp = exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator = exports.ContractsDetailsApi = exports.ContractsDetailsApiFactory = exports.ContractsDetailsApiFp = exports.ContractsDetailsApiFetchParamCreator = exports.ContactoApi = exports.ContactoApiFactory = exports.ContactoApiFp = exports.ContactoApiFetchParamCreator = exports.ComprobanteElectrnicoDePagoCEPApi = exports.ComprobanteElectrnicoDePagoCEPApiFactory = exports.ComprobanteElectrnicoDePagoCEPApiFp = exports.ComprobanteElectrnicoDePagoCEPApiFetchParamCreator = exports.CargosRecurrentesApi = exports.CargosRecurrentesApiFactory = exports.CargosRecurrentesApiFp = exports.CargosRecurrentesApiFetchParamCreator = exports.AutorizacinDeDepsitosApi = exports.AutorizacinDeDepsitosApiFactory = exports.AutorizacinDeDepsitosApiFp = exports.AutorizacinDeDepsitosApiFetchParamCreator = exports.WebhookResponse = exports.Webhook = exports.UseServiceBanking = exports.SubscriptionChangeStatusRequest = exports.SalesPointFound = exports.Product = exports.PaymentCODI = exports.Operations = exports.MessageRequestChanged = exports.CodiOperationsFiltersRequestDTO = exports.CodiCodeRequestDTO = exports.CodiCodeQrResponseDTO = exports.BillingTransaction = exports.Billing = exports.BeneficiariesQueryRegisterStatus = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
exports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiFetchParamCreator = exports.TransferenciasSPIDApi = exports.TransferenciasSPIDApiFactory = exports.TransferenciasSPIDApiFp = exports.TransferenciasSPIDApiFetchParamCreator = exports.TransferenciasSPEIApi = exports.TransferenciasSPEIApiFactory = exports.TransferenciasSPEIApiFp = exports.TransferenciasSPEIApiFetchParamCreator = exports.SuscripcionesApi = exports.SuscripcionesApiFactory = exports.SuscripcionesApiFp = exports.SuscripcionesApiFetchParamCreator = exports.SaldoApi = exports.SaldoApiFactory = exports.SaldoApiFp = exports.SaldoApiFetchParamCreator = exports.PuntosDeVentaCoDiApi = exports.PuntosDeVentaCoDiApiFactory = exports.PuntosDeVentaCoDiApiFp = exports.PuntosDeVentaCoDiApiFetchParamCreator = exports.PeticionesDePagoPorCoDiApi = exports.PeticionesDePagoPorCoDiApiFactory = exports.PeticionesDePagoPorCoDiApiFp = exports.PeticionesDePagoPorCoDiApiFetchParamCreator = exports.OperacionesCoDiApi = exports.OperacionesCoDiApiFactory = exports.OperacionesCoDiApiFp = exports.OperacionesCoDiApiFetchParamCreator = exports.LmitesDeMontosApi = exports.LmitesDeMontosApiFactory = exports.LmitesDeMontosApiFp = exports.LmitesDeMontosApiFetchParamCreator = exports.InstitucionesApi = exports.InstitucionesApiFactory = exports.InstitucionesApiFp = exports.InstitucionesApiFetchParamCreator = exports.FacturasApi = exports.FacturasApiFactory = exports.FacturasApiFp = exports.FacturasApiFetchParamCreator = exports.EmpresasCoDiApi = exports.EmpresasCoDiApiFactory = exports.EmpresasCoDiApiFp = exports.EmpresasCoDiApiFetchParamCreator = void 0;
const url = require("url");
const portableFetch = require("portable-fetch");
const BASE_PATH = "https://sandbox-api.wire4.mx/wire4/1.0.0".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace BeneficiariesQueryRegisterStatus
 */
var BeneficiariesQueryRegisterStatus;
(function (BeneficiariesQueryRegisterStatus) {
    /**
     * @export
     * @enum {string}
     */
    let StatusRequestEnum;
    (function (StatusRequestEnum) {
        StatusRequestEnum[StatusRequestEnum["PENDING"] = 'PENDING'] = "PENDING";
        StatusRequestEnum[StatusRequestEnum["AUTHORIZED"] = 'AUTHORIZED'] = "AUTHORIZED";
    })(StatusRequestEnum = BeneficiariesQueryRegisterStatus.StatusRequestEnum || (BeneficiariesQueryRegisterStatus.StatusRequestEnum = {}));
})(BeneficiariesQueryRegisterStatus = exports.BeneficiariesQueryRegisterStatus || (exports.BeneficiariesQueryRegisterStatus = {}));
/**
 * @export
 * @namespace Billing
 */
var Billing;
(function (Billing) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["PAID"] = 'PAID'] = "PAID";
        StatusEnum[StatusEnum["OMMITED"] = 'OMMITED'] = "OMMITED";
        StatusEnum[StatusEnum["WAITINGPAYMENT"] = 'WAITING_PAYMENT'] = "WAITINGPAYMENT";
        StatusEnum[StatusEnum["EMISSIONPENDING"] = 'EMISSION_PENDING'] = "EMISSIONPENDING";
    })(StatusEnum = Billing.StatusEnum || (Billing.StatusEnum = {}));
})(Billing = exports.Billing || (exports.Billing = {}));
/**
 * @export
 * @namespace BillingTransaction
 */
var BillingTransaction;
(function (BillingTransaction) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["IN"] = 'IN'] = "IN";
        TypeEnum[TypeEnum["OUT"] = 'OUT'] = "OUT";
    })(TypeEnum = BillingTransaction.TypeEnum || (BillingTransaction.TypeEnum = {}));
})(BillingTransaction = exports.BillingTransaction || (exports.BillingTransaction = {}));
/**
 * @export
 * @namespace CodiCodeQrResponseDTO
 */
var CodiCodeQrResponseDTO;
(function (CodiCodeQrResponseDTO) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACCEPTED"] = 'ACCEPTED'] = "ACCEPTED";
        StatusEnum[StatusEnum["RECEIVED"] = 'RECEIVED'] = "RECEIVED";
        StatusEnum[StatusEnum["COMPLETED"] = 'COMPLETED'] = "COMPLETED";
        StatusEnum[StatusEnum["CANCELLED"] = 'CANCELLED'] = "CANCELLED";
        StatusEnum[StatusEnum["POSTPONED"] = 'POSTPONED'] = "POSTPONED";
        StatusEnum[StatusEnum["REJECTED"] = 'REJECTED'] = "REJECTED";
        StatusEnum[StatusEnum["REVERSED"] = 'REVERSED'] = "REVERSED";
        StatusEnum[StatusEnum["PENDING"] = 'PENDING'] = "PENDING";
    })(StatusEnum = CodiCodeQrResponseDTO.StatusEnum || (CodiCodeQrResponseDTO.StatusEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["PUSHNOTIFICATION"] = 'PUSH_NOTIFICATION'] = "PUSHNOTIFICATION";
        TypeEnum[TypeEnum["QRCODE"] = 'QR_CODE'] = "QRCODE";
        TypeEnum[TypeEnum["UNKNOWN"] = 'UNKNOWN'] = "UNKNOWN";
    })(TypeEnum = CodiCodeQrResponseDTO.TypeEnum || (CodiCodeQrResponseDTO.TypeEnum = {}));
})(CodiCodeQrResponseDTO = exports.CodiCodeQrResponseDTO || (exports.CodiCodeQrResponseDTO = {}));
/**
 * @export
 * @namespace CodiCodeRequestDTO
 */
var CodiCodeRequestDTO;
(function (CodiCodeRequestDTO) {
    /**
     * @export
     * @enum {string}
     */
    let PaymentTypeEnum;
    (function (PaymentTypeEnum) {
        PaymentTypeEnum[PaymentTypeEnum["ONEOCCASION"] = 'ONE_OCCASION'] = "ONEOCCASION";
        PaymentTypeEnum[PaymentTypeEnum["RECURRENT"] = 'RECURRENT'] = "RECURRENT";
        PaymentTypeEnum[PaymentTypeEnum["RECURRENTNORECURRENT"] = 'RECURRENT_NO_RECURRENT'] = "RECURRENTNORECURRENT";
        PaymentTypeEnum[PaymentTypeEnum["UNKNOWN"] = 'UNKNOWN'] = "UNKNOWN";
    })(PaymentTypeEnum = CodiCodeRequestDTO.PaymentTypeEnum || (CodiCodeRequestDTO.PaymentTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["PUSHNOTIFICATION"] = 'PUSH_NOTIFICATION'] = "PUSHNOTIFICATION";
        TypeEnum[TypeEnum["QRCODE"] = 'QR_CODE'] = "QRCODE";
        TypeEnum[TypeEnum["UNKNOWN"] = 'UNKNOWN'] = "UNKNOWN";
    })(TypeEnum = CodiCodeRequestDTO.TypeEnum || (CodiCodeRequestDTO.TypeEnum = {}));
})(CodiCodeRequestDTO = exports.CodiCodeRequestDTO || (exports.CodiCodeRequestDTO = {}));
/**
 * @export
 * @namespace CodiOperationsFiltersRequestDTO
 */
var CodiOperationsFiltersRequestDTO;
(function (CodiOperationsFiltersRequestDTO) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACCEPTED"] = 'ACCEPTED'] = "ACCEPTED";
        StatusEnum[StatusEnum["RECEIVED"] = 'RECEIVED'] = "RECEIVED";
        StatusEnum[StatusEnum["COMPLETED"] = 'COMPLETED'] = "COMPLETED";
        StatusEnum[StatusEnum["CANCELLED"] = 'CANCELLED'] = "CANCELLED";
        StatusEnum[StatusEnum["POSTPONED"] = 'POSTPONED'] = "POSTPONED";
        StatusEnum[StatusEnum["REJECTED"] = 'REJECTED'] = "REJECTED";
        StatusEnum[StatusEnum["REVERSED"] = 'REVERSED'] = "REVERSED";
        StatusEnum[StatusEnum["PENDING"] = 'PENDING'] = "PENDING";
    })(StatusEnum = CodiOperationsFiltersRequestDTO.StatusEnum || (CodiOperationsFiltersRequestDTO.StatusEnum = {}));
})(CodiOperationsFiltersRequestDTO = exports.CodiOperationsFiltersRequestDTO || (exports.CodiOperationsFiltersRequestDTO = {}));
/**
 * @export
 * @namespace MessageRequestChanged
 */
var MessageRequestChanged;
(function (MessageRequestChanged) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["AUTHORIZED"] = 'AUTHORIZED'] = "AUTHORIZED";
    })(StatusEnum = MessageRequestChanged.StatusEnum || (MessageRequestChanged.StatusEnum = {}));
})(MessageRequestChanged = exports.MessageRequestChanged || (exports.MessageRequestChanged = {}));
/**
 * @export
 * @namespace Operations
 */
var Operations;
(function (Operations) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACCEPTED"] = 'ACCEPTED'] = "ACCEPTED";
        StatusEnum[StatusEnum["RECEIVED"] = 'RECEIVED'] = "RECEIVED";
        StatusEnum[StatusEnum["COMPLETED"] = 'COMPLETED'] = "COMPLETED";
        StatusEnum[StatusEnum["CANCELLED"] = 'CANCELLED'] = "CANCELLED";
        StatusEnum[StatusEnum["POSTPONED"] = 'POSTPONED'] = "POSTPONED";
        StatusEnum[StatusEnum["REJECTED"] = 'REJECTED'] = "REJECTED";
        StatusEnum[StatusEnum["REVERSED"] = 'REVERSED'] = "REVERSED";
        StatusEnum[StatusEnum["PENDING"] = 'PENDING'] = "PENDING";
    })(StatusEnum = Operations.StatusEnum || (Operations.StatusEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["PUSHNOTIFICATION"] = 'PUSH_NOTIFICATION'] = "PUSHNOTIFICATION";
        TypeEnum[TypeEnum["QRCODE"] = 'QR_CODE'] = "QRCODE";
        TypeEnum[TypeEnum["UNKNOWN"] = 'UNKNOWN'] = "UNKNOWN";
    })(TypeEnum = Operations.TypeEnum || (Operations.TypeEnum = {}));
})(Operations = exports.Operations || (exports.Operations = {}));
/**
 * @export
 * @namespace PaymentCODI
 */
var PaymentCODI;
(function (PaymentCODI) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACCEPTED"] = 'ACCEPTED'] = "ACCEPTED";
        StatusEnum[StatusEnum["RECEIVED"] = 'RECEIVED'] = "RECEIVED";
        StatusEnum[StatusEnum["COMPLETED"] = 'COMPLETED'] = "COMPLETED";
        StatusEnum[StatusEnum["CANCELLED"] = 'CANCELLED'] = "CANCELLED";
        StatusEnum[StatusEnum["POSTPONED"] = 'POSTPONED'] = "POSTPONED";
        StatusEnum[StatusEnum["REJECTED"] = 'REJECTED'] = "REJECTED";
        StatusEnum[StatusEnum["REVERSED"] = 'REVERSED'] = "REVERSED";
        StatusEnum[StatusEnum["PENDING"] = 'PENDING'] = "PENDING";
    })(StatusEnum = PaymentCODI.StatusEnum || (PaymentCODI.StatusEnum = {}));
})(PaymentCODI = exports.PaymentCODI || (exports.PaymentCODI = {}));
/**
 * @export
 * @namespace Product
 */
var Product;
(function (Product) {
    /**
     * @export
     * @enum {string}
     */
    let BillingPeriodEnum;
    (function (BillingPeriodEnum) {
        BillingPeriodEnum[BillingPeriodEnum["WEEKLY"] = 'WEEKLY'] = "WEEKLY";
        BillingPeriodEnum[BillingPeriodEnum["MONTHLY"] = 'MONTHLY'] = "MONTHLY";
        BillingPeriodEnum[BillingPeriodEnum["YEARLY"] = 'YEARLY'] = "YEARLY";
    })(BillingPeriodEnum = Product.BillingPeriodEnum || (Product.BillingPeriodEnum = {}));
})(Product = exports.Product || (exports.Product = {}));
/**
 * @export
 * @namespace SalesPointFound
 */
var SalesPointFound;
(function (SalesPointFound) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACTIVE"] = 'ACTIVE'] = "ACTIVE";
        StatusEnum[StatusEnum["INACTIVE"] = 'INACTIVE'] = "INACTIVE";
    })(StatusEnum = SalesPointFound.StatusEnum || (SalesPointFound.StatusEnum = {}));
})(SalesPointFound = exports.SalesPointFound || (exports.SalesPointFound = {}));
/**
 * @export
 * @namespace SubscriptionChangeStatusRequest
 */
var SubscriptionChangeStatusRequest;
(function (SubscriptionChangeStatusRequest) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACTIVE"] = 'ACTIVE'] = "ACTIVE";
        StatusEnum[StatusEnum["INACTIVE"] = 'INACTIVE'] = "INACTIVE";
    })(StatusEnum = SubscriptionChangeStatusRequest.StatusEnum || (SubscriptionChangeStatusRequest.StatusEnum = {}));
})(SubscriptionChangeStatusRequest = exports.SubscriptionChangeStatusRequest || (exports.SubscriptionChangeStatusRequest = {}));
/**
 * @export
 * @namespace UseServiceBanking
 */
var UseServiceBanking;
(function (UseServiceBanking) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACTIVE"] = 'ACTIVE'] = "ACTIVE";
        StatusEnum[StatusEnum["INACTIVE"] = 'INACTIVE'] = "INACTIVE";
    })(StatusEnum = UseServiceBanking.StatusEnum || (UseServiceBanking.StatusEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let UseEnum;
    (function (UseEnum) {
        UseEnum[UseEnum["WITHDRAWALDEPOSIT"] = 'WITHDRAWAL_DEPOSIT'] = "WITHDRAWALDEPOSIT";
        UseEnum[UseEnum["WITHDRAWAL"] = 'WITHDRAWAL'] = "WITHDRAWAL";
        UseEnum[UseEnum["DEPOSIT"] = 'DEPOSIT'] = "DEPOSIT";
    })(UseEnum = UseServiceBanking.UseEnum || (UseServiceBanking.UseEnum = {}));
})(UseServiceBanking = exports.UseServiceBanking || (exports.UseServiceBanking = {}));
/**
 * @export
 * @namespace Webhook
 */
var Webhook;
(function (Webhook) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACTIVE"] = 'ACTIVE'] = "ACTIVE";
        StatusEnum[StatusEnum["INACTIVE"] = 'INACTIVE'] = "INACTIVE";
        StatusEnum[StatusEnum["DELETED"] = 'DELETED'] = "DELETED";
    })(StatusEnum = Webhook.StatusEnum || (Webhook.StatusEnum = {}));
})(Webhook = exports.Webhook || (exports.Webhook = {}));
/**
 * @export
 * @namespace WebhookResponse
 */
var WebhookResponse;
(function (WebhookResponse) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["ACTIVE"] = 'ACTIVE'] = "ACTIVE";
        StatusEnum[StatusEnum["INACTIVE"] = 'INACTIVE'] = "INACTIVE";
        StatusEnum[StatusEnum["DELETED"] = 'DELETED'] = "DELETED";
    })(StatusEnum = WebhookResponse.StatusEnum || (WebhookResponse.StatusEnum = {}));
})(WebhookResponse = exports.WebhookResponse || (exports.WebhookResponse = {}));
/**
 * AutorizacinDeDepsitosApi - fetch parameter creator
 * @export
 */
const AutorizacinDeDepsitosApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene la información de la autorización de depósitos del contrato relacionado a la suscripción.
         * @summary Consulta autorización de depósitos
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAuthConfigurations(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getDepositAuthConfigurations.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getDepositAuthConfigurations.');
            }
            const localVarPath = `/subscriptions/{subscription}/configurations/deposit-authorization`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Habilita o deshabilita la autorización de depósitos. Devuelve la información final de la autorización de depósitos del contrato relacionado a la suscripción al terminar.
         * @summary Habilita / Deshabilita la autorización de depósitos
         * @param {DepositAuthorizationRequest} body Información para habilitar / deshabilitar la autorización de depósito
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDepositAuthConfigurations(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling putDepositAuthConfigurations.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling putDepositAuthConfigurations.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling putDepositAuthConfigurations.');
            }
            const localVarPath = `/subscriptions/{subscription}/configurations/deposit-authorization`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DepositAuthorizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AutorizacinDeDepsitosApiFetchParamCreator = AutorizacinDeDepsitosApiFetchParamCreator;
/**
 * AutorizacinDeDepsitosApi - functional programming interface
 * @export
 */
const AutorizacinDeDepsitosApiFp = function (configuration) {
    return {
        /**
         * Obtiene la información de la autorización de depósitos del contrato relacionado a la suscripción.
         * @summary Consulta autorización de depósitos
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAuthConfigurations(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.AutorizacinDeDepsitosApiFetchParamCreator)(configuration).getDepositAuthConfigurations(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Habilita o deshabilita la autorización de depósitos. Devuelve la información final de la autorización de depósitos del contrato relacionado a la suscripción al terminar.
         * @summary Habilita / Deshabilita la autorización de depósitos
         * @param {DepositAuthorizationRequest} body Información para habilitar / deshabilitar la autorización de depósito
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDepositAuthConfigurations(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.AutorizacinDeDepsitosApiFetchParamCreator)(configuration).putDepositAuthConfigurations(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AutorizacinDeDepsitosApiFp = AutorizacinDeDepsitosApiFp;
/**
 * AutorizacinDeDepsitosApi - factory interface
 * @export
 */
const AutorizacinDeDepsitosApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene la información de la autorización de depósitos del contrato relacionado a la suscripción.
         * @summary Consulta autorización de depósitos
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAuthConfigurations(authorization, subscription, options) {
            return (0, exports.AutorizacinDeDepsitosApiFp)(configuration).getDepositAuthConfigurations(authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Habilita o deshabilita la autorización de depósitos. Devuelve la información final de la autorización de depósitos del contrato relacionado a la suscripción al terminar.
         * @summary Habilita / Deshabilita la autorización de depósitos
         * @param {DepositAuthorizationRequest} body Información para habilitar / deshabilitar la autorización de depósito
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDepositAuthConfigurations(body, authorization, subscription, options) {
            return (0, exports.AutorizacinDeDepsitosApiFp)(configuration).putDepositAuthConfigurations(body, authorization, subscription, options)(fetch, basePath);
        },
    };
};
exports.AutorizacinDeDepsitosApiFactory = AutorizacinDeDepsitosApiFactory;
/**
 * AutorizacinDeDepsitosApi - object-oriented interface
 * @export
 * @class AutorizacinDeDepsitosApi
 * @extends {BaseAPI}
 */
class AutorizacinDeDepsitosApi extends BaseAPI {
    /**
     * Obtiene la información de la autorización de depósitos del contrato relacionado a la suscripción.
     * @summary Consulta autorización de depósitos
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorizacinDeDepsitosApi
     */
    getDepositAuthConfigurations(authorization, subscription, options) {
        return (0, exports.AutorizacinDeDepsitosApiFp)(this.configuration).getDepositAuthConfigurations(authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Habilita o deshabilita la autorización de depósitos. Devuelve la información final de la autorización de depósitos del contrato relacionado a la suscripción al terminar.
     * @summary Habilita / Deshabilita la autorización de depósitos
     * @param {DepositAuthorizationRequest} body Información para habilitar / deshabilitar la autorización de depósito
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutorizacinDeDepsitosApi
     */
    putDepositAuthConfigurations(body, authorization, subscription, options) {
        return (0, exports.AutorizacinDeDepsitosApiFp)(this.configuration).putDepositAuthConfigurations(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
}
exports.AutorizacinDeDepsitosApi = AutorizacinDeDepsitosApi;
/**
 * CargosRecurrentesApi - fetch parameter creator
 * @export
 */
const CargosRecurrentesApiFetchParamCreator = function (configuration) {
    return {
        /**
         *  Se solicita la desuscripción de un cargo recurrente activo. En el request llevará el orderId que identifica el cargo recurrente a eliminar/dar de baja se deshabilitará tanto de openpay como del sistem wire4.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
         * @summary Cancelación/desubscripción de cargos recurrentes
         * @param {string} authorization Header para token
         * @param {string} order_id orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurringChargeUsingDELETE(authorization, order_id, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling deleteRecurringChargeUsingDELETE.');
            }
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id', 'Required parameter order_id was null or undefined when calling deleteRecurringChargeUsingDELETE.');
            }
            const localVarPath = `/recurring-charge/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Se registra una solicitud para generar un plan de cargos recurrentes. En la respuesta se proporcionará una dirección URL que lo llevará al sitio donde se le solicitará ingresar los datos de tarjeta a la que se aplicarán los cargos de acuerdo al plan seleccionado.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
         * @summary Registro de cargos recurrentes
         * @param {RecurringChargeRequest} body Información de la solicitud para aplicar cargos recurrentes
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRecurringChargeUsingPOST(body, authorization, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerRecurringChargeUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling registerRecurringChargeUsingPOST.');
            }
            const localVarPath = `/recurring-charge`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RecurringChargeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CargosRecurrentesApiFetchParamCreator = CargosRecurrentesApiFetchParamCreator;
/**
 * CargosRecurrentesApi - functional programming interface
 * @export
 */
const CargosRecurrentesApiFp = function (configuration) {
    return {
        /**
         *  Se solicita la desuscripción de un cargo recurrente activo. En el request llevará el orderId que identifica el cargo recurrente a eliminar/dar de baja se deshabilitará tanto de openpay como del sistem wire4.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
         * @summary Cancelación/desubscripción de cargos recurrentes
         * @param {string} authorization Header para token
         * @param {string} order_id orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurringChargeUsingDELETE(authorization, order_id, options) {
            const localVarFetchArgs = (0, exports.CargosRecurrentesApiFetchParamCreator)(configuration).deleteRecurringChargeUsingDELETE(authorization, order_id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *  Se registra una solicitud para generar un plan de cargos recurrentes. En la respuesta se proporcionará una dirección URL que lo llevará al sitio donde se le solicitará ingresar los datos de tarjeta a la que se aplicarán los cargos de acuerdo al plan seleccionado.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
         * @summary Registro de cargos recurrentes
         * @param {RecurringChargeRequest} body Información de la solicitud para aplicar cargos recurrentes
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRecurringChargeUsingPOST(body, authorization, options) {
            const localVarFetchArgs = (0, exports.CargosRecurrentesApiFetchParamCreator)(configuration).registerRecurringChargeUsingPOST(body, authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.CargosRecurrentesApiFp = CargosRecurrentesApiFp;
/**
 * CargosRecurrentesApi - factory interface
 * @export
 */
const CargosRecurrentesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *  Se solicita la desuscripción de un cargo recurrente activo. En el request llevará el orderId que identifica el cargo recurrente a eliminar/dar de baja se deshabilitará tanto de openpay como del sistem wire4.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
         * @summary Cancelación/desubscripción de cargos recurrentes
         * @param {string} authorization Header para token
         * @param {string} order_id orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurringChargeUsingDELETE(authorization, order_id, options) {
            return (0, exports.CargosRecurrentesApiFp)(configuration).deleteRecurringChargeUsingDELETE(authorization, order_id, options)(fetch, basePath);
        },
        /**
         *  Se registra una solicitud para generar un plan de cargos recurrentes. En la respuesta se proporcionará una dirección URL que lo llevará al sitio donde se le solicitará ingresar los datos de tarjeta a la que se aplicarán los cargos de acuerdo al plan seleccionado.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
         * @summary Registro de cargos recurrentes
         * @param {RecurringChargeRequest} body Información de la solicitud para aplicar cargos recurrentes
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRecurringChargeUsingPOST(body, authorization, options) {
            return (0, exports.CargosRecurrentesApiFp)(configuration).registerRecurringChargeUsingPOST(body, authorization, options)(fetch, basePath);
        },
    };
};
exports.CargosRecurrentesApiFactory = CargosRecurrentesApiFactory;
/**
 * CargosRecurrentesApi - object-oriented interface
 * @export
 * @class CargosRecurrentesApi
 * @extends {BaseAPI}
 */
class CargosRecurrentesApi extends BaseAPI {
    /**
     *  Se solicita la desuscripción de un cargo recurrente activo. En el request llevará el orderId que identifica el cargo recurrente a eliminar/dar de baja se deshabilitará tanto de openpay como del sistem wire4.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
     * @summary Cancelación/desubscripción de cargos recurrentes
     * @param {string} authorization Header para token
     * @param {string} order_id orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosRecurrentesApi
     */
    deleteRecurringChargeUsingDELETE(authorization, order_id, options) {
        return (0, exports.CargosRecurrentesApiFp)(this.configuration).deleteRecurringChargeUsingDELETE(authorization, order_id, options)(this.fetch, this.basePath);
    }
    /**
     *  Se registra una solicitud para generar un plan de cargos recurrentes. En la respuesta se proporcionará una dirección URL que lo llevará al sitio donde se le solicitará ingresar los datos de tarjeta a la que se aplicarán los cargos de acuerdo al plan seleccionado.<br> Nota: Debe considerar que para hacer uso de esta funcionalidad debe contar con un scope  especial
     * @summary Registro de cargos recurrentes
     * @param {RecurringChargeRequest} body Información de la solicitud para aplicar cargos recurrentes
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CargosRecurrentesApi
     */
    registerRecurringChargeUsingPOST(body, authorization, options) {
        return (0, exports.CargosRecurrentesApiFp)(this.configuration).registerRecurringChargeUsingPOST(body, authorization, options)(this.fetch, this.basePath);
    }
}
exports.CargosRecurrentesApi = CargosRecurrentesApi;
/**
 * ComprobanteElectrnicoDePagoCEPApi - fetch parameter creator
 * @export
 */
const ComprobanteElectrnicoDePagoCEPApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Consulta el CEP de un pago realizado a través del SPEI, si es que este se encuentra disponible en BANXICO.
         * @summary Consulta de CEP
         * @param {CepSearchBanxico} body Información para buscar un CEP
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainTransactionCepUsingPOST(body, authorization, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling obtainTransactionCepUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling obtainTransactionCepUsingPOST.');
            }
            const localVarPath = `/ceps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CepSearchBanxico" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ComprobanteElectrnicoDePagoCEPApiFetchParamCreator = ComprobanteElectrnicoDePagoCEPApiFetchParamCreator;
/**
 * ComprobanteElectrnicoDePagoCEPApi - functional programming interface
 * @export
 */
const ComprobanteElectrnicoDePagoCEPApiFp = function (configuration) {
    return {
        /**
         * Consulta el CEP de un pago realizado a través del SPEI, si es que este se encuentra disponible en BANXICO.
         * @summary Consulta de CEP
         * @param {CepSearchBanxico} body Información para buscar un CEP
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainTransactionCepUsingPOST(body, authorization, options) {
            const localVarFetchArgs = (0, exports.ComprobanteElectrnicoDePagoCEPApiFetchParamCreator)(configuration).obtainTransactionCepUsingPOST(body, authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ComprobanteElectrnicoDePagoCEPApiFp = ComprobanteElectrnicoDePagoCEPApiFp;
/**
 * ComprobanteElectrnicoDePagoCEPApi - factory interface
 * @export
 */
const ComprobanteElectrnicoDePagoCEPApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Consulta el CEP de un pago realizado a través del SPEI, si es que este se encuentra disponible en BANXICO.
         * @summary Consulta de CEP
         * @param {CepSearchBanxico} body Información para buscar un CEP
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainTransactionCepUsingPOST(body, authorization, options) {
            return (0, exports.ComprobanteElectrnicoDePagoCEPApiFp)(configuration).obtainTransactionCepUsingPOST(body, authorization, options)(fetch, basePath);
        },
    };
};
exports.ComprobanteElectrnicoDePagoCEPApiFactory = ComprobanteElectrnicoDePagoCEPApiFactory;
/**
 * ComprobanteElectrnicoDePagoCEPApi - object-oriented interface
 * @export
 * @class ComprobanteElectrnicoDePagoCEPApi
 * @extends {BaseAPI}
 */
class ComprobanteElectrnicoDePagoCEPApi extends BaseAPI {
    /**
     * Consulta el CEP de un pago realizado a través del SPEI, si es que este se encuentra disponible en BANXICO.
     * @summary Consulta de CEP
     * @param {CepSearchBanxico} body Información para buscar un CEP
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComprobanteElectrnicoDePagoCEPApi
     */
    obtainTransactionCepUsingPOST(body, authorization, options) {
        return (0, exports.ComprobanteElectrnicoDePagoCEPApiFp)(this.configuration).obtainTransactionCepUsingPOST(body, authorization, options)(this.fetch, this.basePath);
    }
}
exports.ComprobanteElectrnicoDePagoCEPApi = ComprobanteElectrnicoDePagoCEPApi;
/**
 * ContactoApi - fetch parameter creator
 * @export
 */
const ContactoApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Notifica a un asesor Monex para que se ponga en contacto con un posible cliente.
         * @summary Solicitud de contacto
         * @param {ContactRequest} body Información del contacto
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendContactUsingPOST(body, authorization, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling sendContactUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling sendContactUsingPOST.');
            }
            const localVarPath = `/contact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ContactRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ContactoApiFetchParamCreator = ContactoApiFetchParamCreator;
/**
 * ContactoApi - functional programming interface
 * @export
 */
const ContactoApiFp = function (configuration) {
    return {
        /**
         * Notifica a un asesor Monex para que se ponga en contacto con un posible cliente.
         * @summary Solicitud de contacto
         * @param {ContactRequest} body Información del contacto
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendContactUsingPOST(body, authorization, options) {
            const localVarFetchArgs = (0, exports.ContactoApiFetchParamCreator)(configuration).sendContactUsingPOST(body, authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ContactoApiFp = ContactoApiFp;
/**
 * ContactoApi - factory interface
 * @export
 */
const ContactoApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Notifica a un asesor Monex para que se ponga en contacto con un posible cliente.
         * @summary Solicitud de contacto
         * @param {ContactRequest} body Información del contacto
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendContactUsingPOST(body, authorization, options) {
            return (0, exports.ContactoApiFp)(configuration).sendContactUsingPOST(body, authorization, options)(fetch, basePath);
        },
    };
};
exports.ContactoApiFactory = ContactoApiFactory;
/**
 * ContactoApi - object-oriented interface
 * @export
 * @class ContactoApi
 * @extends {BaseAPI}
 */
class ContactoApi extends BaseAPI {
    /**
     * Notifica a un asesor Monex para que se ponga en contacto con un posible cliente.
     * @summary Solicitud de contacto
     * @param {ContactRequest} body Información del contacto
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactoApi
     */
    sendContactUsingPOST(body, authorization, options) {
        return (0, exports.ContactoApiFp)(this.configuration).sendContactUsingPOST(body, authorization, options)(this.fetch, this.basePath);
    }
}
exports.ContactoApi = ContactoApi;
/**
 * ContractsDetailsApi - fetch parameter creator
 * @export
 */
const ContractsDetailsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Se obtiene la URL para la autorización del usuario Monex.
         * @summary Devuelve la URL para autorización del usuario Monex
         * @param {PreMonexAuthorization} body Información para la autorización
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization(body, authorization, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createAuthorization.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling createAuthorization.');
            }
            const localVarPath = `/onboarding/accounts/authorize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PreMonexAuthorization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtienen los detalles de los usuarios autorizados de Monex.
         * @summary Obtiene los usuarios autorizados
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {string} request_id El identificador de la petición a esta API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainAuthorizedUsers(authorization, X_ACCESS_KEY, request_id, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling obtainAuthorizedUsers.');
            }
            // verify required parameter 'X_ACCESS_KEY' is not null or undefined
            if (X_ACCESS_KEY === null || X_ACCESS_KEY === undefined) {
                throw new RequiredError('X_ACCESS_KEY', 'Required parameter X_ACCESS_KEY was null or undefined when calling obtainAuthorizedUsers.');
            }
            // verify required parameter 'request_id' is not null or undefined
            if (request_id === null || request_id === undefined) {
                throw new RequiredError('request_id', 'Required parameter request_id was null or undefined when calling obtainAuthorizedUsers.');
            }
            const localVarPath = `/onboarding/accounts/{requestId}/authorized-users`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(request_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (X_ACCESS_KEY !== undefined && X_ACCESS_KEY !== null) {
                localVarHeaderParameter['X-ACCESS-KEY'] = String(X_ACCESS_KEY);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtienen los detalles de los usuarios autorizados por contrato Monex.
         * @summary Obtiene los usuarios autorizados por contrato
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {string} [contract] El contrato Monex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainAuthorizedUsersByContract(authorization, X_ACCESS_KEY, contract, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling obtainAuthorizedUsersByContract.');
            }
            // verify required parameter 'X_ACCESS_KEY' is not null or undefined
            if (X_ACCESS_KEY === null || X_ACCESS_KEY === undefined) {
                throw new RequiredError('X_ACCESS_KEY', 'Required parameter X_ACCESS_KEY was null or undefined when calling obtainAuthorizedUsersByContract.');
            }
            const localVarPath = `/onboarding/accounts/authorized-users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contract !== undefined) {
                localVarQueryParameter['contract'] = contract;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (X_ACCESS_KEY !== undefined && X_ACCESS_KEY !== null) {
                localVarHeaderParameter['X-ACCESS-KEY'] = String(X_ACCESS_KEY);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detalles de la compañía relacionada con el contrato de Monex.
         * @summary Obtiene los detalles de la empresa del contrato
         * @param {ContractDetailRequest} body Información para obtener los detalles de la companía
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainContractDetails(body, authorization, X_ACCESS_KEY, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling obtainContractDetails.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling obtainContractDetails.');
            }
            // verify required parameter 'X_ACCESS_KEY' is not null or undefined
            if (X_ACCESS_KEY === null || X_ACCESS_KEY === undefined) {
                throw new RequiredError('X_ACCESS_KEY', 'Required parameter X_ACCESS_KEY was null or undefined when calling obtainContractDetails.');
            }
            const localVarPath = `/onboarding/accounts/details`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (X_ACCESS_KEY !== undefined && X_ACCESS_KEY !== null) {
                localVarHeaderParameter['X-ACCESS-KEY'] = String(X_ACCESS_KEY);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ContractDetailRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ContractsDetailsApiFetchParamCreator = ContractsDetailsApiFetchParamCreator;
/**
 * ContractsDetailsApi - functional programming interface
 * @export
 */
const ContractsDetailsApiFp = function (configuration) {
    return {
        /**
         * Se obtiene la URL para la autorización del usuario Monex.
         * @summary Devuelve la URL para autorización del usuario Monex
         * @param {PreMonexAuthorization} body Información para la autorización
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization(body, authorization, options) {
            const localVarFetchArgs = (0, exports.ContractsDetailsApiFetchParamCreator)(configuration).createAuthorization(body, authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtienen los detalles de los usuarios autorizados de Monex.
         * @summary Obtiene los usuarios autorizados
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {string} request_id El identificador de la petición a esta API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainAuthorizedUsers(authorization, X_ACCESS_KEY, request_id, options) {
            const localVarFetchArgs = (0, exports.ContractsDetailsApiFetchParamCreator)(configuration).obtainAuthorizedUsers(authorization, X_ACCESS_KEY, request_id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtienen los detalles de los usuarios autorizados por contrato Monex.
         * @summary Obtiene los usuarios autorizados por contrato
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {string} [contract] El contrato Monex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainAuthorizedUsersByContract(authorization, X_ACCESS_KEY, contract, options) {
            const localVarFetchArgs = (0, exports.ContractsDetailsApiFetchParamCreator)(configuration).obtainAuthorizedUsersByContract(authorization, X_ACCESS_KEY, contract, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Detalles de la compañía relacionada con el contrato de Monex.
         * @summary Obtiene los detalles de la empresa del contrato
         * @param {ContractDetailRequest} body Información para obtener los detalles de la companía
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainContractDetails(body, authorization, X_ACCESS_KEY, options) {
            const localVarFetchArgs = (0, exports.ContractsDetailsApiFetchParamCreator)(configuration).obtainContractDetails(body, authorization, X_ACCESS_KEY, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ContractsDetailsApiFp = ContractsDetailsApiFp;
/**
 * ContractsDetailsApi - factory interface
 * @export
 */
const ContractsDetailsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Se obtiene la URL para la autorización del usuario Monex.
         * @summary Devuelve la URL para autorización del usuario Monex
         * @param {PreMonexAuthorization} body Información para la autorización
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization(body, authorization, options) {
            return (0, exports.ContractsDetailsApiFp)(configuration).createAuthorization(body, authorization, options)(fetch, basePath);
        },
        /**
         * Obtienen los detalles de los usuarios autorizados de Monex.
         * @summary Obtiene los usuarios autorizados
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {string} request_id El identificador de la petición a esta API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainAuthorizedUsers(authorization, X_ACCESS_KEY, request_id, options) {
            return (0, exports.ContractsDetailsApiFp)(configuration).obtainAuthorizedUsers(authorization, X_ACCESS_KEY, request_id, options)(fetch, basePath);
        },
        /**
         * Obtienen los detalles de los usuarios autorizados por contrato Monex.
         * @summary Obtiene los usuarios autorizados por contrato
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {string} [contract] El contrato Monex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainAuthorizedUsersByContract(authorization, X_ACCESS_KEY, contract, options) {
            return (0, exports.ContractsDetailsApiFp)(configuration).obtainAuthorizedUsersByContract(authorization, X_ACCESS_KEY, contract, options)(fetch, basePath);
        },
        /**
         * Detalles de la compañía relacionada con el contrato de Monex.
         * @summary Obtiene los detalles de la empresa del contrato
         * @param {ContractDetailRequest} body Información para obtener los detalles de la companía
         * @param {string} authorization Header para token
         * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainContractDetails(body, authorization, X_ACCESS_KEY, options) {
            return (0, exports.ContractsDetailsApiFp)(configuration).obtainContractDetails(body, authorization, X_ACCESS_KEY, options)(fetch, basePath);
        },
    };
};
exports.ContractsDetailsApiFactory = ContractsDetailsApiFactory;
/**
 * ContractsDetailsApi - object-oriented interface
 * @export
 * @class ContractsDetailsApi
 * @extends {BaseAPI}
 */
class ContractsDetailsApi extends BaseAPI {
    /**
     * Se obtiene la URL para la autorización del usuario Monex.
     * @summary Devuelve la URL para autorización del usuario Monex
     * @param {PreMonexAuthorization} body Información para la autorización
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsDetailsApi
     */
    createAuthorization(body, authorization, options) {
        return (0, exports.ContractsDetailsApiFp)(this.configuration).createAuthorization(body, authorization, options)(this.fetch, this.basePath);
    }
    /**
     * Obtienen los detalles de los usuarios autorizados de Monex.
     * @summary Obtiene los usuarios autorizados
     * @param {string} authorization Header para token
     * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
     * @param {string} request_id El identificador de la petición a esta API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsDetailsApi
     */
    obtainAuthorizedUsers(authorization, X_ACCESS_KEY, request_id, options) {
        return (0, exports.ContractsDetailsApiFp)(this.configuration).obtainAuthorizedUsers(authorization, X_ACCESS_KEY, request_id, options)(this.fetch, this.basePath);
    }
    /**
     * Obtienen los detalles de los usuarios autorizados por contrato Monex.
     * @summary Obtiene los usuarios autorizados por contrato
     * @param {string} authorization Header para token
     * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
     * @param {string} [contract] El contrato Monex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsDetailsApi
     */
    obtainAuthorizedUsersByContract(authorization, X_ACCESS_KEY, contract, options) {
        return (0, exports.ContractsDetailsApiFp)(this.configuration).obtainAuthorizedUsersByContract(authorization, X_ACCESS_KEY, contract, options)(this.fetch, this.basePath);
    }
    /**
     * Detalles de la compañía relacionada con el contrato de Monex.
     * @summary Obtiene los detalles de la empresa del contrato
     * @param {ContractDetailRequest} body Información para obtener los detalles de la companía
     * @param {string} authorization Header para token
     * @param {string} X_ACCESS_KEY La llave de acceso de la aplicación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsDetailsApi
     */
    obtainContractDetails(body, authorization, X_ACCESS_KEY, options) {
        return (0, exports.ContractsDetailsApiFp)(this.configuration).obtainContractDetails(body, authorization, X_ACCESS_KEY, options)(this.fetch, this.basePath);
    }
}
exports.ContractsDetailsApi = ContractsDetailsApi;
/**
 * CuentasDeBeneficiariosSPEIApi - fetch parameter creator
 * @export
 */
const CuentasDeBeneficiariosSPEIApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Solicta la agrupación de las cuentas de beneficiarios en estado pendiente para que sean autorizadas,  para ello se crea un conjunto de éstas que puede incluir tanto de SPEI como de SPID. Además se debe indicar las urls de redirección en caso de error y éxito
         * @summary Solicitud para agrupar cuentas de beneficiarios SPEI/SPID en estado pendiente.
         * @param {UrlsRedirect} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeAccountsPendingPUT(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling authorizeAccountsPendingPUT.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling authorizeAccountsPendingPUT.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling authorizeAccountsPendingPUT.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/pending`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UrlsRedirect" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina la cuenta de beneficiario proporcionada relacionada al contrato perteneciente a la suscripción. La cuenta a borrar debe ser una que opere con SPEI.
         * @summary Elimina la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} account Es la cuenta del beneficiario que será eliminada.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountUsingDELETE(authorization, account, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling deleteAccountUsingDELETE.');
            }
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account', 'Required parameter account was null or undefined when calling deleteAccountUsingDELETE.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling deleteAccountUsingDELETE.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spei/{account}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene las posibles relaciones existentes para registrar beneficiarios en Monex. Se debe invocar este recurso antes de pre-registrar una cuenta de beneficiario.
         * @summary Consulta de relaciones
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRelationshipsMonexUsingGET(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getAvailableRelationshipsMonexUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getAvailableRelationshipsMonexUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/relationships`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene los beneficiarios enviados para registro en una petición al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex, que pertenezcan a la petición que se solicita.
         * @summary Consulta los beneficiarios por el identificador de la petición de registro
         * @param {string} authorization Header para token
         * @param {string} request_id El identificador de la petición del registro de beneficiarios a esta API.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiariesByRequestId(authorization, request_id, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getBeneficiariesByRequestId.');
            }
            // verify required parameter 'request_id' is not null or undefined
            if (request_id === null || request_id === undefined) {
                throw new RequiredError('request_id', 'Required parameter request_id was null or undefined when calling getBeneficiariesByRequestId.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getBeneficiariesByRequestId.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spei/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(request_id)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene los beneficiarios registrados al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
         * @summary Consulta los beneficiarios registrados
         * @param {string} authorization Header para token
         * @param {string} [account] Es la cuenta del beneficiario, podría ser teléfono celular (es de 10 dígitos), Tarjeta de débito (TDD, es de 16 dígitos) o cuenta CLABE (es de 18 dígitos). &lt;br/&gt;&lt;br/&gt;Por ejemplo Teléfono celular: 5525072600, TDD: 4323 1234 5678 9123, CLABE: 032180000118359719.
         * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del recurso de las &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
         * @param {string} [beneficiary_name] Es el nombre del beneficiario.
         * @param {string} [end_date] Es la fecha de inicio del perido a filtrar en formato dd-mm-yyyy.
         * @param {string} [init_date] Es la fºecha de inicio del perido a filtrar en formato dd-mm-yyyy.
         * @param {string} [page] Es el número de página.
         * @param {string} [rfc] Es el Registro Federal de Controbuyentes (RFC) del beneficiario.
         * @param {string} [size] Es el tamaño de página.
         * @param {string} [status] Es el estado (estatus) de la cuenta. Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiariesForAccountUsingGET(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getBeneficiariesForAccountUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getBeneficiariesForAccountUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spei`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }
            if (beneficiary_bank !== undefined) {
                localVarQueryParameter['beneficiary_bank'] = beneficiary_bank;
            }
            if (beneficiary_name !== undefined) {
                localVarQueryParameter['beneficiary_name'] = beneficiary_name;
            }
            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = end_date;
            }
            if (init_date !== undefined) {
                localVarQueryParameter['init_date'] = init_date;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (rfc !== undefined) {
                localVarQueryParameter['rfc'] = rfc;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pre-registra una o más cuentas de beneficiario en la plataforma de Wire4, ésta le proporcionará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
         * @summary Pre-registro de cuentas de beneficiarios SPEI®.
         * @param {AccountRequest} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preRegisterAccountsUsingPOST(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling preRegisterAccountsUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling preRegisterAccountsUsingPOST.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling preRegisterAccountsUsingPOST.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spei`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AccountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina uno o más beneficiarios que se encuentran en estado pendiente de confirmar (autorizar) de la cuenta del cliente Monex relacionada a la suscripción.
         * @summary Eliminación de beneficiarios SPEI® sin confirmar
         * @param {string} authorization Header para token
         * @param {string} request_id Es el identificador con el que se dió de alta a los beneficiarios (viene en el cuerpo de la respuesta del &lt;a href&#x3D;\&quot;#operation/getAvailableRelationshipsMonexUsingGET\&quot;&gt;pre-registro de beneficiarios&lt;/a&gt;), los registros bajo éste campo van a ser eliminados.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBeneficiariesPendingUsingDELETE(authorization, request_id, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling removeBeneficiariesPendingUsingDELETE.');
            }
            // verify required parameter 'request_id' is not null or undefined
            if (request_id === null || request_id === undefined) {
                throw new RequiredError('request_id', 'Required parameter request_id was null or undefined when calling removeBeneficiariesPendingUsingDELETE.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling removeBeneficiariesPendingUsingDELETE.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spei/request/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(request_id)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se crea una solicitud para actualizar el monto límite a la cuenta de beneficiario proporcionada y relacionada al contrato perteneciente a la subscripción. Una vez enviada la solicitud se retornará una URl que lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar la actualización del monto límite.
         * @summary Solicitud para actualizar el monto límite de una cuenta
         * @param {AmountRequest} body Información de la cuenta y el monto límite a actualizar.
         * @param {string} authorization Header para token
         * @param {string} account Es la cuenta que va a ser actualizada.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAmountLimitAccountUsingPUT(body, authorization, account, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateAmountLimitAccountUsingPUT.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling updateAmountLimitAccountUsingPUT.');
            }
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account', 'Required parameter account was null or undefined when calling updateAmountLimitAccountUsingPUT.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling updateAmountLimitAccountUsingPUT.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spei/{account}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AmountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator = CuentasDeBeneficiariosSPEIApiFetchParamCreator;
/**
 * CuentasDeBeneficiariosSPEIApi - functional programming interface
 * @export
 */
const CuentasDeBeneficiariosSPEIApiFp = function (configuration) {
    return {
        /**
         * Solicta la agrupación de las cuentas de beneficiarios en estado pendiente para que sean autorizadas,  para ello se crea un conjunto de éstas que puede incluir tanto de SPEI como de SPID. Además se debe indicar las urls de redirección en caso de error y éxito
         * @summary Solicitud para agrupar cuentas de beneficiarios SPEI/SPID en estado pendiente.
         * @param {UrlsRedirect} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeAccountsPendingPUT(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).authorizeAccountsPendingPUT(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Elimina la cuenta de beneficiario proporcionada relacionada al contrato perteneciente a la suscripción. La cuenta a borrar debe ser una que opere con SPEI.
         * @summary Elimina la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} account Es la cuenta del beneficiario que será eliminada.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountUsingDELETE(authorization, account, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).deleteAccountUsingDELETE(authorization, account, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtiene las posibles relaciones existentes para registrar beneficiarios en Monex. Se debe invocar este recurso antes de pre-registrar una cuenta de beneficiario.
         * @summary Consulta de relaciones
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRelationshipsMonexUsingGET(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).getAvailableRelationshipsMonexUsingGET(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtiene los beneficiarios enviados para registro en una petición al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex, que pertenezcan a la petición que se solicita.
         * @summary Consulta los beneficiarios por el identificador de la petición de registro
         * @param {string} authorization Header para token
         * @param {string} request_id El identificador de la petición del registro de beneficiarios a esta API.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiariesByRequestId(authorization, request_id, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).getBeneficiariesByRequestId(authorization, request_id, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtiene los beneficiarios registrados al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
         * @summary Consulta los beneficiarios registrados
         * @param {string} authorization Header para token
         * @param {string} [account] Es la cuenta del beneficiario, podría ser teléfono celular (es de 10 dígitos), Tarjeta de débito (TDD, es de 16 dígitos) o cuenta CLABE (es de 18 dígitos). &lt;br/&gt;&lt;br/&gt;Por ejemplo Teléfono celular: 5525072600, TDD: 4323 1234 5678 9123, CLABE: 032180000118359719.
         * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del recurso de las &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
         * @param {string} [beneficiary_name] Es el nombre del beneficiario.
         * @param {string} [end_date] Es la fecha de inicio del perido a filtrar en formato dd-mm-yyyy.
         * @param {string} [init_date] Es la fºecha de inicio del perido a filtrar en formato dd-mm-yyyy.
         * @param {string} [page] Es el número de página.
         * @param {string} [rfc] Es el Registro Federal de Controbuyentes (RFC) del beneficiario.
         * @param {string} [size] Es el tamaño de página.
         * @param {string} [status] Es el estado (estatus) de la cuenta. Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiariesForAccountUsingGET(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).getBeneficiariesForAccountUsingGET(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pre-registra una o más cuentas de beneficiario en la plataforma de Wire4, ésta le proporcionará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
         * @summary Pre-registro de cuentas de beneficiarios SPEI®.
         * @param {AccountRequest} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preRegisterAccountsUsingPOST(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).preRegisterAccountsUsingPOST(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Elimina uno o más beneficiarios que se encuentran en estado pendiente de confirmar (autorizar) de la cuenta del cliente Monex relacionada a la suscripción.
         * @summary Eliminación de beneficiarios SPEI® sin confirmar
         * @param {string} authorization Header para token
         * @param {string} request_id Es el identificador con el que se dió de alta a los beneficiarios (viene en el cuerpo de la respuesta del &lt;a href&#x3D;\&quot;#operation/getAvailableRelationshipsMonexUsingGET\&quot;&gt;pre-registro de beneficiarios&lt;/a&gt;), los registros bajo éste campo van a ser eliminados.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBeneficiariesPendingUsingDELETE(authorization, request_id, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).removeBeneficiariesPendingUsingDELETE(authorization, request_id, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Se crea una solicitud para actualizar el monto límite a la cuenta de beneficiario proporcionada y relacionada al contrato perteneciente a la subscripción. Una vez enviada la solicitud se retornará una URl que lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar la actualización del monto límite.
         * @summary Solicitud para actualizar el monto límite de una cuenta
         * @param {AmountRequest} body Información de la cuenta y el monto límite a actualizar.
         * @param {string} authorization Header para token
         * @param {string} account Es la cuenta que va a ser actualizada.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAmountLimitAccountUsingPUT(body, authorization, account, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPEIApiFetchParamCreator)(configuration).updateAmountLimitAccountUsingPUT(body, authorization, account, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.CuentasDeBeneficiariosSPEIApiFp = CuentasDeBeneficiariosSPEIApiFp;
/**
 * CuentasDeBeneficiariosSPEIApi - factory interface
 * @export
 */
const CuentasDeBeneficiariosSPEIApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Solicta la agrupación de las cuentas de beneficiarios en estado pendiente para que sean autorizadas,  para ello se crea un conjunto de éstas que puede incluir tanto de SPEI como de SPID. Además se debe indicar las urls de redirección en caso de error y éxito
         * @summary Solicitud para agrupar cuentas de beneficiarios SPEI/SPID en estado pendiente.
         * @param {UrlsRedirect} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeAccountsPendingPUT(body, authorization, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).authorizeAccountsPendingPUT(body, authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Elimina la cuenta de beneficiario proporcionada relacionada al contrato perteneciente a la suscripción. La cuenta a borrar debe ser una que opere con SPEI.
         * @summary Elimina la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} account Es la cuenta del beneficiario que será eliminada.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountUsingDELETE(authorization, account, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).deleteAccountUsingDELETE(authorization, account, subscription, options)(fetch, basePath);
        },
        /**
         * Obtiene las posibles relaciones existentes para registrar beneficiarios en Monex. Se debe invocar este recurso antes de pre-registrar una cuenta de beneficiario.
         * @summary Consulta de relaciones
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRelationshipsMonexUsingGET(authorization, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).getAvailableRelationshipsMonexUsingGET(authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Obtiene los beneficiarios enviados para registro en una petición al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex, que pertenezcan a la petición que se solicita.
         * @summary Consulta los beneficiarios por el identificador de la petición de registro
         * @param {string} authorization Header para token
         * @param {string} request_id El identificador de la petición del registro de beneficiarios a esta API.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiariesByRequestId(authorization, request_id, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).getBeneficiariesByRequestId(authorization, request_id, subscription, options)(fetch, basePath);
        },
        /**
         * Obtiene los beneficiarios registrados al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
         * @summary Consulta los beneficiarios registrados
         * @param {string} authorization Header para token
         * @param {string} [account] Es la cuenta del beneficiario, podría ser teléfono celular (es de 10 dígitos), Tarjeta de débito (TDD, es de 16 dígitos) o cuenta CLABE (es de 18 dígitos). &lt;br/&gt;&lt;br/&gt;Por ejemplo Teléfono celular: 5525072600, TDD: 4323 1234 5678 9123, CLABE: 032180000118359719.
         * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del recurso de las &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
         * @param {string} [beneficiary_name] Es el nombre del beneficiario.
         * @param {string} [end_date] Es la fecha de inicio del perido a filtrar en formato dd-mm-yyyy.
         * @param {string} [init_date] Es la fºecha de inicio del perido a filtrar en formato dd-mm-yyyy.
         * @param {string} [page] Es el número de página.
         * @param {string} [rfc] Es el Registro Federal de Controbuyentes (RFC) del beneficiario.
         * @param {string} [size] Es el tamaño de página.
         * @param {string} [status] Es el estado (estatus) de la cuenta. Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiariesForAccountUsingGET(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).getBeneficiariesForAccountUsingGET(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options)(fetch, basePath);
        },
        /**
         * Pre-registra una o más cuentas de beneficiario en la plataforma de Wire4, ésta le proporcionará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
         * @summary Pre-registro de cuentas de beneficiarios SPEI®.
         * @param {AccountRequest} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preRegisterAccountsUsingPOST(body, authorization, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).preRegisterAccountsUsingPOST(body, authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Elimina uno o más beneficiarios que se encuentran en estado pendiente de confirmar (autorizar) de la cuenta del cliente Monex relacionada a la suscripción.
         * @summary Eliminación de beneficiarios SPEI® sin confirmar
         * @param {string} authorization Header para token
         * @param {string} request_id Es el identificador con el que se dió de alta a los beneficiarios (viene en el cuerpo de la respuesta del &lt;a href&#x3D;\&quot;#operation/getAvailableRelationshipsMonexUsingGET\&quot;&gt;pre-registro de beneficiarios&lt;/a&gt;), los registros bajo éste campo van a ser eliminados.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBeneficiariesPendingUsingDELETE(authorization, request_id, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).removeBeneficiariesPendingUsingDELETE(authorization, request_id, subscription, options)(fetch, basePath);
        },
        /**
         * Se crea una solicitud para actualizar el monto límite a la cuenta de beneficiario proporcionada y relacionada al contrato perteneciente a la subscripción. Una vez enviada la solicitud se retornará una URl que lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar la actualización del monto límite.
         * @summary Solicitud para actualizar el monto límite de una cuenta
         * @param {AmountRequest} body Información de la cuenta y el monto límite a actualizar.
         * @param {string} authorization Header para token
         * @param {string} account Es la cuenta que va a ser actualizada.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAmountLimitAccountUsingPUT(body, authorization, account, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(configuration).updateAmountLimitAccountUsingPUT(body, authorization, account, subscription, options)(fetch, basePath);
        },
    };
};
exports.CuentasDeBeneficiariosSPEIApiFactory = CuentasDeBeneficiariosSPEIApiFactory;
/**
 * CuentasDeBeneficiariosSPEIApi - object-oriented interface
 * @export
 * @class CuentasDeBeneficiariosSPEIApi
 * @extends {BaseAPI}
 */
class CuentasDeBeneficiariosSPEIApi extends BaseAPI {
    /**
     * Solicta la agrupación de las cuentas de beneficiarios en estado pendiente para que sean autorizadas,  para ello se crea un conjunto de éstas que puede incluir tanto de SPEI como de SPID. Además se debe indicar las urls de redirección en caso de error y éxito
     * @summary Solicitud para agrupar cuentas de beneficiarios SPEI/SPID en estado pendiente.
     * @param {UrlsRedirect} body Información de la cuenta del beneficiario
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    authorizeAccountsPendingPUT(body, authorization, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).authorizeAccountsPendingPUT(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Elimina la cuenta de beneficiario proporcionada relacionada al contrato perteneciente a la suscripción. La cuenta a borrar debe ser una que opere con SPEI.
     * @summary Elimina la cuenta del beneficiario
     * @param {string} authorization Header para token
     * @param {string} account Es la cuenta del beneficiario que será eliminada.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    deleteAccountUsingDELETE(authorization, account, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).deleteAccountUsingDELETE(authorization, account, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Obtiene las posibles relaciones existentes para registrar beneficiarios en Monex. Se debe invocar este recurso antes de pre-registrar una cuenta de beneficiario.
     * @summary Consulta de relaciones
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    getAvailableRelationshipsMonexUsingGET(authorization, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).getAvailableRelationshipsMonexUsingGET(authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Obtiene los beneficiarios enviados para registro en una petición al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex, que pertenezcan a la petición que se solicita.
     * @summary Consulta los beneficiarios por el identificador de la petición de registro
     * @param {string} authorization Header para token
     * @param {string} request_id El identificador de la petición del registro de beneficiarios a esta API.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    getBeneficiariesByRequestId(authorization, request_id, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).getBeneficiariesByRequestId(authorization, request_id, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Obtiene los beneficiarios registrados al contrato relacionado con la suscripción, Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
     * @summary Consulta los beneficiarios registrados
     * @param {string} authorization Header para token
     * @param {string} [account] Es la cuenta del beneficiario, podría ser teléfono celular (es de 10 dígitos), Tarjeta de débito (TDD, es de 16 dígitos) o cuenta CLABE (es de 18 dígitos). &lt;br/&gt;&lt;br/&gt;Por ejemplo Teléfono celular: 5525072600, TDD: 4323 1234 5678 9123, CLABE: 032180000118359719.
     * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del recurso de las &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
     * @param {string} [beneficiary_name] Es el nombre del beneficiario.
     * @param {string} [end_date] Es la fecha de inicio del perido a filtrar en formato dd-mm-yyyy.
     * @param {string} [init_date] Es la fºecha de inicio del perido a filtrar en formato dd-mm-yyyy.
     * @param {string} [page] Es el número de página.
     * @param {string} [rfc] Es el Registro Federal de Controbuyentes (RFC) del beneficiario.
     * @param {string} [size] Es el tamaño de página.
     * @param {string} [status] Es el estado (estatus) de la cuenta. Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    getBeneficiariesForAccountUsingGET(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).getBeneficiariesForAccountUsingGET(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Pre-registra una o más cuentas de beneficiario en la plataforma de Wire4, ésta le proporcionará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
     * @summary Pre-registro de cuentas de beneficiarios SPEI®.
     * @param {AccountRequest} body Información de la cuenta del beneficiario
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    preRegisterAccountsUsingPOST(body, authorization, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).preRegisterAccountsUsingPOST(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Elimina uno o más beneficiarios que se encuentran en estado pendiente de confirmar (autorizar) de la cuenta del cliente Monex relacionada a la suscripción.
     * @summary Eliminación de beneficiarios SPEI® sin confirmar
     * @param {string} authorization Header para token
     * @param {string} request_id Es el identificador con el que se dió de alta a los beneficiarios (viene en el cuerpo de la respuesta del &lt;a href&#x3D;\&quot;#operation/getAvailableRelationshipsMonexUsingGET\&quot;&gt;pre-registro de beneficiarios&lt;/a&gt;), los registros bajo éste campo van a ser eliminados.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    removeBeneficiariesPendingUsingDELETE(authorization, request_id, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).removeBeneficiariesPendingUsingDELETE(authorization, request_id, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Se crea una solicitud para actualizar el monto límite a la cuenta de beneficiario proporcionada y relacionada al contrato perteneciente a la subscripción. Una vez enviada la solicitud se retornará una URl que lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar la actualización del monto límite.
     * @summary Solicitud para actualizar el monto límite de una cuenta
     * @param {AmountRequest} body Información de la cuenta y el monto límite a actualizar.
     * @param {string} authorization Header para token
     * @param {string} account Es la cuenta que va a ser actualizada.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPEIApi
     */
    updateAmountLimitAccountUsingPUT(body, authorization, account, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPEIApiFp)(this.configuration).updateAmountLimitAccountUsingPUT(body, authorization, account, subscription, options)(this.fetch, this.basePath);
    }
}
exports.CuentasDeBeneficiariosSPEIApi = CuentasDeBeneficiariosSPEIApi;
/**
 * CuentasDeBeneficiariosSPIDApi - fetch parameter creator
 * @export
 */
const CuentasDeBeneficiariosSPIDApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene los beneficiarios SPID registrados al contrato relacionado con la suscripción. Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
         * @summary Consulta los beneficiarios SPID registrados
         * @param {string} authorization Header para token
         * @param {string} [account] Cuenta del beneficiario, puede ser CLABE (18 dígitos), Tarjeta de débito  (TDD, 16 dígitos) o número de celular (10 dígitos).
         * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del catalogo de &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
         * @param {string} [beneficiary_name] Es el nombre del beneficiario.
         * @param {string} [end_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
         * @param {string} [init_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
         * @param {string} [page] Es el número de página.
         * @param {string} [rfc] Es el Registro Federal de Contribuyentes (RFC) del beneficiario.
         * @param {string} [size] Es el tamaño de página.
         * @param {string} [status] Es el estado (estatus) de la cuenta, Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpidBeneficiariesForAccount(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getSpidBeneficiariesForAccount.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getSpidBeneficiariesForAccount.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spid`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }
            if (beneficiary_bank !== undefined) {
                localVarQueryParameter['beneficiary_bank'] = beneficiary_bank;
            }
            if (beneficiary_name !== undefined) {
                localVarQueryParameter['beneficiary_name'] = beneficiary_name;
            }
            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = end_date;
            }
            if (init_date !== undefined) {
                localVarQueryParameter['init_date'] = init_date;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (rfc !== undefined) {
                localVarQueryParameter['rfc'] = rfc;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pre-registra una o más cuentas de beneficiario SPID® en la plataforma de Wire4, ésta le proporcionaará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
         * @summary Pre-registro de cuentas de beneficiarios SPID®
         * @param {AccountSpid} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preRegisterAccountsUsingPOST1(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling preRegisterAccountsUsingPOST1.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling preRegisterAccountsUsingPOST1.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling preRegisterAccountsUsingPOST1.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spid`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AccountSpid" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CuentasDeBeneficiariosSPIDApiFetchParamCreator = CuentasDeBeneficiariosSPIDApiFetchParamCreator;
/**
 * CuentasDeBeneficiariosSPIDApi - functional programming interface
 * @export
 */
const CuentasDeBeneficiariosSPIDApiFp = function (configuration) {
    return {
        /**
         * Obtiene los beneficiarios SPID registrados al contrato relacionado con la suscripción. Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
         * @summary Consulta los beneficiarios SPID registrados
         * @param {string} authorization Header para token
         * @param {string} [account] Cuenta del beneficiario, puede ser CLABE (18 dígitos), Tarjeta de débito  (TDD, 16 dígitos) o número de celular (10 dígitos).
         * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del catalogo de &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
         * @param {string} [beneficiary_name] Es el nombre del beneficiario.
         * @param {string} [end_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
         * @param {string} [init_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
         * @param {string} [page] Es el número de página.
         * @param {string} [rfc] Es el Registro Federal de Contribuyentes (RFC) del beneficiario.
         * @param {string} [size] Es el tamaño de página.
         * @param {string} [status] Es el estado (estatus) de la cuenta, Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpidBeneficiariesForAccount(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPIDApiFetchParamCreator)(configuration).getSpidBeneficiariesForAccount(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pre-registra una o más cuentas de beneficiario SPID® en la plataforma de Wire4, ésta le proporcionaará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
         * @summary Pre-registro de cuentas de beneficiarios SPID®
         * @param {AccountSpid} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preRegisterAccountsUsingPOST1(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.CuentasDeBeneficiariosSPIDApiFetchParamCreator)(configuration).preRegisterAccountsUsingPOST1(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.CuentasDeBeneficiariosSPIDApiFp = CuentasDeBeneficiariosSPIDApiFp;
/**
 * CuentasDeBeneficiariosSPIDApi - factory interface
 * @export
 */
const CuentasDeBeneficiariosSPIDApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene los beneficiarios SPID registrados al contrato relacionado con la suscripción. Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
         * @summary Consulta los beneficiarios SPID registrados
         * @param {string} authorization Header para token
         * @param {string} [account] Cuenta del beneficiario, puede ser CLABE (18 dígitos), Tarjeta de débito  (TDD, 16 dígitos) o número de celular (10 dígitos).
         * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del catalogo de &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
         * @param {string} [beneficiary_name] Es el nombre del beneficiario.
         * @param {string} [end_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
         * @param {string} [init_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
         * @param {string} [page] Es el número de página.
         * @param {string} [rfc] Es el Registro Federal de Contribuyentes (RFC) del beneficiario.
         * @param {string} [size] Es el tamaño de página.
         * @param {string} [status] Es el estado (estatus) de la cuenta, Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpidBeneficiariesForAccount(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPIDApiFp)(configuration).getSpidBeneficiariesForAccount(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options)(fetch, basePath);
        },
        /**
         * Pre-registra una o más cuentas de beneficiario SPID® en la plataforma de Wire4, ésta le proporcionaará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
         * @summary Pre-registro de cuentas de beneficiarios SPID®
         * @param {AccountSpid} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preRegisterAccountsUsingPOST1(body, authorization, subscription, options) {
            return (0, exports.CuentasDeBeneficiariosSPIDApiFp)(configuration).preRegisterAccountsUsingPOST1(body, authorization, subscription, options)(fetch, basePath);
        },
    };
};
exports.CuentasDeBeneficiariosSPIDApiFactory = CuentasDeBeneficiariosSPIDApiFactory;
/**
 * CuentasDeBeneficiariosSPIDApi - object-oriented interface
 * @export
 * @class CuentasDeBeneficiariosSPIDApi
 * @extends {BaseAPI}
 */
class CuentasDeBeneficiariosSPIDApi extends BaseAPI {
    /**
     * Obtiene los beneficiarios SPID registrados al contrato relacionado con la suscripción. Los beneficiarios son los que actualmente se encuentran registrados en banca Monex.
     * @summary Consulta los beneficiarios SPID registrados
     * @param {string} authorization Header para token
     * @param {string} [account] Cuenta del beneficiario, puede ser CLABE (18 dígitos), Tarjeta de débito  (TDD, 16 dígitos) o número de celular (10 dígitos).
     * @param {string} [beneficiary_bank] Es la clave del banco beneficiario. Se puede obtener del catalogo de &lt;a href&#x3D;\&quot;#operation/getAllInstitutionsUsingGET\&quot;&gt;instituciones.&lt;/a&gt;
     * @param {string} [beneficiary_name] Es el nombre del beneficiario.
     * @param {string} [end_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
     * @param {string} [init_date] Es la fecha de inicio del periodo a filtrar en formato dd-mm-yyyy.
     * @param {string} [page] Es el número de página.
     * @param {string} [rfc] Es el Registro Federal de Contribuyentes (RFC) del beneficiario.
     * @param {string} [size] Es el tamaño de página.
     * @param {string} [status] Es el estado (estatus) de la cuenta, Los valores pueden ser &lt;b&gt;PENDING&lt;/b&gt; y &lt;b&gt;REGISTERED&lt;/b&gt;.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPIDApi
     */
    getSpidBeneficiariesForAccount(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPIDApiFp)(this.configuration).getSpidBeneficiariesForAccount(authorization, account, beneficiary_bank, beneficiary_name, end_date, init_date, page, rfc, size, status, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Pre-registra una o más cuentas de beneficiario SPID® en la plataforma de Wire4, ésta le proporcionaará una URL donde lo llevará al centro de autorización para que el cuentahabiente Monex ingrese su llave digital para confirmar el alta de las cuentas de beneficiarios.<br/> Los posibles valores de <em>relationship</em> y <em>kind_of_relationship</em> se deben  obtener de <a href=\"#operation/getAvailableRelationshipsMonexUsingGET\">/subscriptions/{subscription}/beneficiaries/relationships.</a><br/><br/>La confirmación de registro en Monex se realizará a través de una notificación a los webhooks registrados con el evento de tipo <a href=\"#section/Eventos/Tipos-de-Eventos\">ACCOUNT.CREATED.</a>
     * @summary Pre-registro de cuentas de beneficiarios SPID®
     * @param {AccountSpid} body Información de la cuenta del beneficiario
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CuentasDeBeneficiariosSPIDApi
     */
    preRegisterAccountsUsingPOST1(body, authorization, subscription, options) {
        return (0, exports.CuentasDeBeneficiariosSPIDApiFp)(this.configuration).preRegisterAccountsUsingPOST1(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
}
exports.CuentasDeBeneficiariosSPIDApi = CuentasDeBeneficiariosSPIDApi;
/**
 * DepositantesApi - fetch parameter creator
 * @export
 */
const DepositantesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene la cantidad el total de depositantes asociados al contrato relacionado a la suscripción.
         * @summary Número de depositantes por suscripción
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositantsTotalsUsingGET(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getDepositantsTotalsUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getDepositantsTotalsUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/depositants/count`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista de depositantes asociados al contrato relacionado a la suscripción.
         * @summary Consulta de cuentas de depositantes
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositantsUsingGET(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getDepositantsUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getDepositantsUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/depositants`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra un nuevo depositante en el contrato asociado a la suscripción. Si intenta registrar un depositante que previamente se había registrado, se devolverá la cuenta clabe asociada al Álias que está intentando registrar. Queda bajo responsabilidad del cliente verificar que los álias sean únicos en sus sistemas.
         * @summary Registra un nuevo depositante
         * @param {DepositantsRegister} body Depositant info
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDepositantsUsingPOST(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerDepositantsUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling registerDepositantsUsingPOST.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling registerDepositantsUsingPOST.');
            }
            const localVarPath = `/subscriptions/{subscription}/depositants`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DepositantsRegister" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DepositantesApiFetchParamCreator = DepositantesApiFetchParamCreator;
/**
 * DepositantesApi - functional programming interface
 * @export
 */
const DepositantesApiFp = function (configuration) {
    return {
        /**
         * Obtiene la cantidad el total de depositantes asociados al contrato relacionado a la suscripción.
         * @summary Número de depositantes por suscripción
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositantsTotalsUsingGET(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.DepositantesApiFetchParamCreator)(configuration).getDepositantsTotalsUsingGET(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtiene una lista de depositantes asociados al contrato relacionado a la suscripción.
         * @summary Consulta de cuentas de depositantes
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositantsUsingGET(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.DepositantesApiFetchParamCreator)(configuration).getDepositantsUsingGET(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registra un nuevo depositante en el contrato asociado a la suscripción. Si intenta registrar un depositante que previamente se había registrado, se devolverá la cuenta clabe asociada al Álias que está intentando registrar. Queda bajo responsabilidad del cliente verificar que los álias sean únicos en sus sistemas.
         * @summary Registra un nuevo depositante
         * @param {DepositantsRegister} body Depositant info
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDepositantsUsingPOST(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.DepositantesApiFetchParamCreator)(configuration).registerDepositantsUsingPOST(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.DepositantesApiFp = DepositantesApiFp;
/**
 * DepositantesApi - factory interface
 * @export
 */
const DepositantesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene la cantidad el total de depositantes asociados al contrato relacionado a la suscripción.
         * @summary Número de depositantes por suscripción
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositantsTotalsUsingGET(authorization, subscription, options) {
            return (0, exports.DepositantesApiFp)(configuration).getDepositantsTotalsUsingGET(authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Obtiene una lista de depositantes asociados al contrato relacionado a la suscripción.
         * @summary Consulta de cuentas de depositantes
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositantsUsingGET(authorization, subscription, options) {
            return (0, exports.DepositantesApiFp)(configuration).getDepositantsUsingGET(authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Registra un nuevo depositante en el contrato asociado a la suscripción. Si intenta registrar un depositante que previamente se había registrado, se devolverá la cuenta clabe asociada al Álias que está intentando registrar. Queda bajo responsabilidad del cliente verificar que los álias sean únicos en sus sistemas.
         * @summary Registra un nuevo depositante
         * @param {DepositantsRegister} body Depositant info
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDepositantsUsingPOST(body, authorization, subscription, options) {
            return (0, exports.DepositantesApiFp)(configuration).registerDepositantsUsingPOST(body, authorization, subscription, options)(fetch, basePath);
        },
    };
};
exports.DepositantesApiFactory = DepositantesApiFactory;
/**
 * DepositantesApi - object-oriented interface
 * @export
 * @class DepositantesApi
 * @extends {BaseAPI}
 */
class DepositantesApi extends BaseAPI {
    /**
     * Obtiene la cantidad el total de depositantes asociados al contrato relacionado a la suscripción.
     * @summary Número de depositantes por suscripción
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositantesApi
     */
    getDepositantsTotalsUsingGET(authorization, subscription, options) {
        return (0, exports.DepositantesApiFp)(this.configuration).getDepositantsTotalsUsingGET(authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Obtiene una lista de depositantes asociados al contrato relacionado a la suscripción.
     * @summary Consulta de cuentas de depositantes
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositantesApi
     */
    getDepositantsUsingGET(authorization, subscription, options) {
        return (0, exports.DepositantesApiFp)(this.configuration).getDepositantsUsingGET(authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Registra un nuevo depositante en el contrato asociado a la suscripción. Si intenta registrar un depositante que previamente se había registrado, se devolverá la cuenta clabe asociada al Álias que está intentando registrar. Queda bajo responsabilidad del cliente verificar que los álias sean únicos en sus sistemas.
     * @summary Registra un nuevo depositante
     * @param {DepositantsRegister} body Depositant info
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositantesApi
     */
    registerDepositantsUsingPOST(body, authorization, subscription, options) {
        return (0, exports.DepositantesApiFp)(this.configuration).registerDepositantsUsingPOST(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
}
exports.DepositantesApi = DepositantesApi;
/**
 * EmpresasCoDiApi - fetch parameter creator
 * @export
 */
const EmpresasCoDiApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Consulta de empresas CODI® registradas para la aplicación.
         * @summary Consulta de empresas CODI®
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainCompanies(authorization, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling obtainCompanies.');
            }
            const localVarPath = `/codi/companies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra una empresa para hacer uso de operaciones CODI®.<br><br> <b>Nota:<b> Es requerido tener el certificado emitido por BANXICO® asi como el Nombre de la empresa, Nombre comercial y el Registro Federal de Contribuyentes (RFC) de la empresa.<br/>
         * @summary Registro de empresas CODI®
         * @param {CompanyRequested} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerCompanyUsingPOST(body, authorization, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerCompanyUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling registerCompanyUsingPOST.');
            }
            const localVarPath = `/codi/companies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CompanyRequested" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EmpresasCoDiApiFetchParamCreator = EmpresasCoDiApiFetchParamCreator;
/**
 * EmpresasCoDiApi - functional programming interface
 * @export
 */
const EmpresasCoDiApiFp = function (configuration) {
    return {
        /**
         * Consulta de empresas CODI® registradas para la aplicación.
         * @summary Consulta de empresas CODI®
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainCompanies(authorization, options) {
            const localVarFetchArgs = (0, exports.EmpresasCoDiApiFetchParamCreator)(configuration).obtainCompanies(authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registra una empresa para hacer uso de operaciones CODI®.<br><br> <b>Nota:<b> Es requerido tener el certificado emitido por BANXICO® asi como el Nombre de la empresa, Nombre comercial y el Registro Federal de Contribuyentes (RFC) de la empresa.<br/>
         * @summary Registro de empresas CODI®
         * @param {CompanyRequested} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerCompanyUsingPOST(body, authorization, options) {
            const localVarFetchArgs = (0, exports.EmpresasCoDiApiFetchParamCreator)(configuration).registerCompanyUsingPOST(body, authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EmpresasCoDiApiFp = EmpresasCoDiApiFp;
/**
 * EmpresasCoDiApi - factory interface
 * @export
 */
const EmpresasCoDiApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Consulta de empresas CODI® registradas para la aplicación.
         * @summary Consulta de empresas CODI®
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainCompanies(authorization, options) {
            return (0, exports.EmpresasCoDiApiFp)(configuration).obtainCompanies(authorization, options)(fetch, basePath);
        },
        /**
         * Registra una empresa para hacer uso de operaciones CODI®.<br><br> <b>Nota:<b> Es requerido tener el certificado emitido por BANXICO® asi como el Nombre de la empresa, Nombre comercial y el Registro Federal de Contribuyentes (RFC) de la empresa.<br/>
         * @summary Registro de empresas CODI®
         * @param {CompanyRequested} body Información de la cuenta del beneficiario
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerCompanyUsingPOST(body, authorization, options) {
            return (0, exports.EmpresasCoDiApiFp)(configuration).registerCompanyUsingPOST(body, authorization, options)(fetch, basePath);
        },
    };
};
exports.EmpresasCoDiApiFactory = EmpresasCoDiApiFactory;
/**
 * EmpresasCoDiApi - object-oriented interface
 * @export
 * @class EmpresasCoDiApi
 * @extends {BaseAPI}
 */
class EmpresasCoDiApi extends BaseAPI {
    /**
     * Consulta de empresas CODI® registradas para la aplicación.
     * @summary Consulta de empresas CODI®
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmpresasCoDiApi
     */
    obtainCompanies(authorization, options) {
        return (0, exports.EmpresasCoDiApiFp)(this.configuration).obtainCompanies(authorization, options)(this.fetch, this.basePath);
    }
    /**
     * Registra una empresa para hacer uso de operaciones CODI®.<br><br> <b>Nota:<b> Es requerido tener el certificado emitido por BANXICO® asi como el Nombre de la empresa, Nombre comercial y el Registro Federal de Contribuyentes (RFC) de la empresa.<br/>
     * @summary Registro de empresas CODI®
     * @param {CompanyRequested} body Información de la cuenta del beneficiario
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmpresasCoDiApi
     */
    registerCompanyUsingPOST(body, authorization, options) {
        return (0, exports.EmpresasCoDiApiFp)(this.configuration).registerCompanyUsingPOST(body, authorization, options)(this.fetch, this.basePath);
    }
}
exports.EmpresasCoDiApi = EmpresasCoDiApi;
/**
 * FacturasApi - fetch parameter creator
 * @export
 */
const FacturasApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Se debe especificar el identificador de la factura
         * @summary Consulta de facturas por identificador
         * @param {string} authorization Header para token
         * @param {string} id Identificador de la factura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsReportByIdUsingGET(authorization, id, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling billingsReportByIdUsingGET.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling billingsReportByIdUsingGET.');
            }
            const localVarPath = `/billings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Es posible filtrar por periodo de fecha yyyy-MM, por ejemplo 2019-11
         * @summary Consulta de facturas
         * @param {string} authorization Header para token
         * @param {string} [period] Filtro de fecha yyyy-MM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsReportUsingGET(authorization, period, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling billingsReportUsingGET.');
            }
            const localVarPath = `/billings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FacturasApiFetchParamCreator = FacturasApiFetchParamCreator;
/**
 * FacturasApi - functional programming interface
 * @export
 */
const FacturasApiFp = function (configuration) {
    return {
        /**
         * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Se debe especificar el identificador de la factura
         * @summary Consulta de facturas por identificador
         * @param {string} authorization Header para token
         * @param {string} id Identificador de la factura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsReportByIdUsingGET(authorization, id, options) {
            const localVarFetchArgs = (0, exports.FacturasApiFetchParamCreator)(configuration).billingsReportByIdUsingGET(authorization, id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Es posible filtrar por periodo de fecha yyyy-MM, por ejemplo 2019-11
         * @summary Consulta de facturas
         * @param {string} authorization Header para token
         * @param {string} [period] Filtro de fecha yyyy-MM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsReportUsingGET(authorization, period, options) {
            const localVarFetchArgs = (0, exports.FacturasApiFetchParamCreator)(configuration).billingsReportUsingGET(authorization, period, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.FacturasApiFp = FacturasApiFp;
/**
 * FacturasApi - factory interface
 * @export
 */
const FacturasApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Se debe especificar el identificador de la factura
         * @summary Consulta de facturas por identificador
         * @param {string} authorization Header para token
         * @param {string} id Identificador de la factura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsReportByIdUsingGET(authorization, id, options) {
            return (0, exports.FacturasApiFp)(configuration).billingsReportByIdUsingGET(authorization, id, options)(fetch, basePath);
        },
        /**
         * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Es posible filtrar por periodo de fecha yyyy-MM, por ejemplo 2019-11
         * @summary Consulta de facturas
         * @param {string} authorization Header para token
         * @param {string} [period] Filtro de fecha yyyy-MM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsReportUsingGET(authorization, period, options) {
            return (0, exports.FacturasApiFp)(configuration).billingsReportUsingGET(authorization, period, options)(fetch, basePath);
        },
    };
};
exports.FacturasApiFactory = FacturasApiFactory;
/**
 * FacturasApi - object-oriented interface
 * @export
 * @class FacturasApi
 * @extends {BaseAPI}
 */
class FacturasApi extends BaseAPI {
    /**
     * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Se debe especificar el identificador de la factura
     * @summary Consulta de facturas por identificador
     * @param {string} authorization Header para token
     * @param {string} id Identificador de la factura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacturasApi
     */
    billingsReportByIdUsingGET(authorization, id, options) {
        return (0, exports.FacturasApiFp)(this.configuration).billingsReportByIdUsingGET(authorization, id, options)(this.fetch, this.basePath);
    }
    /**
     * Consulta las facturas emitidas por conceptos de uso de la plataforma y operaciones realizadas tanto de entrada como de salida. Es posible filtrar por periodo de fecha yyyy-MM, por ejemplo 2019-11
     * @summary Consulta de facturas
     * @param {string} authorization Header para token
     * @param {string} [period] Filtro de fecha yyyy-MM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacturasApi
     */
    billingsReportUsingGET(authorization, period, options) {
        return (0, exports.FacturasApiFp)(this.configuration).billingsReportUsingGET(authorization, period, options)(this.fetch, this.basePath);
    }
}
exports.FacturasApi = FacturasApi;
/**
 * InstitucionesApi - fetch parameter creator
 * @export
 */
const InstitucionesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Se obtiene un listado de las instituciones bancarias y la información de cada una de estas.
         * @summary Consulta de instituciones bancarias
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInstitutionsUsingGET(authorization, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getAllInstitutionsUsingGET.');
            }
            const localVarPath = `/institutions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.InstitucionesApiFetchParamCreator = InstitucionesApiFetchParamCreator;
/**
 * InstitucionesApi - functional programming interface
 * @export
 */
const InstitucionesApiFp = function (configuration) {
    return {
        /**
         * Se obtiene un listado de las instituciones bancarias y la información de cada una de estas.
         * @summary Consulta de instituciones bancarias
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInstitutionsUsingGET(authorization, options) {
            const localVarFetchArgs = (0, exports.InstitucionesApiFetchParamCreator)(configuration).getAllInstitutionsUsingGET(authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.InstitucionesApiFp = InstitucionesApiFp;
/**
 * InstitucionesApi - factory interface
 * @export
 */
const InstitucionesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Se obtiene un listado de las instituciones bancarias y la información de cada una de estas.
         * @summary Consulta de instituciones bancarias
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInstitutionsUsingGET(authorization, options) {
            return (0, exports.InstitucionesApiFp)(configuration).getAllInstitutionsUsingGET(authorization, options)(fetch, basePath);
        },
    };
};
exports.InstitucionesApiFactory = InstitucionesApiFactory;
/**
 * InstitucionesApi - object-oriented interface
 * @export
 * @class InstitucionesApi
 * @extends {BaseAPI}
 */
class InstitucionesApi extends BaseAPI {
    /**
     * Se obtiene un listado de las instituciones bancarias y la información de cada una de estas.
     * @summary Consulta de instituciones bancarias
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitucionesApi
     */
    getAllInstitutionsUsingGET(authorization, options) {
        return (0, exports.InstitucionesApiFp)(this.configuration).getAllInstitutionsUsingGET(authorization, options)(this.fetch, this.basePath);
    }
}
exports.InstitucionesApi = InstitucionesApi;
/**
 * LmitesDeMontosApi - fetch parameter creator
 * @export
 */
const LmitesDeMontosApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Consulta las configuraciones para el contrato asocaido al enrolamiento en la aplicación.
         * @summary Consulta de configuraciones
         * @param {string} authorization Header para token
         * @param {string} suscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainConfigurationsLimits(authorization, suscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling obtainConfigurationsLimits.');
            }
            // verify required parameter 'suscription' is not null or undefined
            if (suscription === null || suscription === undefined) {
                throw new RequiredError('suscription', 'Required parameter suscription was null or undefined when calling obtainConfigurationsLimits.');
            }
            const localVarPath = `/subscriptions/{suscription}/configurations`
                .replace(`{${"suscription"}}`, encodeURIComponent(String(suscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza las configuraciones de un contrato asociado a una suscripción
         * @summary Actualiza configuraciones por suscripción
         * @param {UpdateConfigurationsRequestDTO} body updateConfigurationsResquestDTO
         * @param {string} authorization Header para token
         * @param {string} suscription suscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurations(body, authorization, suscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateConfigurations.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling updateConfigurations.');
            }
            // verify required parameter 'suscription' is not null or undefined
            if (suscription === null || suscription === undefined) {
                throw new RequiredError('suscription', 'Required parameter suscription was null or undefined when calling updateConfigurations.');
            }
            const localVarPath = `/subscriptions/{suscription}/configurations`
                .replace(`{${"suscription"}}`, encodeURIComponent(String(suscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UpdateConfigurationsRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.LmitesDeMontosApiFetchParamCreator = LmitesDeMontosApiFetchParamCreator;
/**
 * LmitesDeMontosApi - functional programming interface
 * @export
 */
const LmitesDeMontosApiFp = function (configuration) {
    return {
        /**
         * Consulta las configuraciones para el contrato asocaido al enrolamiento en la aplicación.
         * @summary Consulta de configuraciones
         * @param {string} authorization Header para token
         * @param {string} suscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainConfigurationsLimits(authorization, suscription, options) {
            const localVarFetchArgs = (0, exports.LmitesDeMontosApiFetchParamCreator)(configuration).obtainConfigurationsLimits(authorization, suscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Actualiza las configuraciones de un contrato asociado a una suscripción
         * @summary Actualiza configuraciones por suscripción
         * @param {UpdateConfigurationsRequestDTO} body updateConfigurationsResquestDTO
         * @param {string} authorization Header para token
         * @param {string} suscription suscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurations(body, authorization, suscription, options) {
            const localVarFetchArgs = (0, exports.LmitesDeMontosApiFetchParamCreator)(configuration).updateConfigurations(body, authorization, suscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.LmitesDeMontosApiFp = LmitesDeMontosApiFp;
/**
 * LmitesDeMontosApi - factory interface
 * @export
 */
const LmitesDeMontosApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Consulta las configuraciones para el contrato asocaido al enrolamiento en la aplicación.
         * @summary Consulta de configuraciones
         * @param {string} authorization Header para token
         * @param {string} suscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainConfigurationsLimits(authorization, suscription, options) {
            return (0, exports.LmitesDeMontosApiFp)(configuration).obtainConfigurationsLimits(authorization, suscription, options)(fetch, basePath);
        },
        /**
         * Actualiza las configuraciones de un contrato asociado a una suscripción
         * @summary Actualiza configuraciones por suscripción
         * @param {UpdateConfigurationsRequestDTO} body updateConfigurationsResquestDTO
         * @param {string} authorization Header para token
         * @param {string} suscription suscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurations(body, authorization, suscription, options) {
            return (0, exports.LmitesDeMontosApiFp)(configuration).updateConfigurations(body, authorization, suscription, options)(fetch, basePath);
        },
    };
};
exports.LmitesDeMontosApiFactory = LmitesDeMontosApiFactory;
/**
 * LmitesDeMontosApi - object-oriented interface
 * @export
 * @class LmitesDeMontosApi
 * @extends {BaseAPI}
 */
class LmitesDeMontosApi extends BaseAPI {
    /**
     * Consulta las configuraciones para el contrato asocaido al enrolamiento en la aplicación.
     * @summary Consulta de configuraciones
     * @param {string} authorization Header para token
     * @param {string} suscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LmitesDeMontosApi
     */
    obtainConfigurationsLimits(authorization, suscription, options) {
        return (0, exports.LmitesDeMontosApiFp)(this.configuration).obtainConfigurationsLimits(authorization, suscription, options)(this.fetch, this.basePath);
    }
    /**
     * Actualiza las configuraciones de un contrato asociado a una suscripción
     * @summary Actualiza configuraciones por suscripción
     * @param {UpdateConfigurationsRequestDTO} body updateConfigurationsResquestDTO
     * @param {string} authorization Header para token
     * @param {string} suscription suscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LmitesDeMontosApi
     */
    updateConfigurations(body, authorization, suscription, options) {
        return (0, exports.LmitesDeMontosApiFp)(this.configuration).updateConfigurations(body, authorization, suscription, options)(this.fetch, this.basePath);
    }
}
exports.LmitesDeMontosApi = LmitesDeMontosApi;
/**
 * OperacionesCoDiApi - fetch parameter creator
 * @export
 */
const OperacionesCoDiApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene las operaciones generadas a partir de peticiones de pago CODI® de forma paginada, pudiendo aplicar filtros.
         * @summary Consulta de operaciones
         * @param {CodiOperationsFiltersRequestDTO} [body] Filtros de busqueda
         * @param {string} authorization Header para token
         * @param {string} [company_id] Es el identificador de empresa CODI®.
         * @param {string} [page] Es el número de pago.
         * @param {string} [sales_point_id] Es el identificador del punto de venta.
         * @param {string} [size] Es el tamaño de página.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consultCodiOperations(body, authorization, company_id, page, sales_point_id, size, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling consultCodiOperations.');
            }
            const localVarPath = `/codi/charges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (company_id !== undefined) {
                localVarQueryParameter['company_id'] = company_id;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (sales_point_id !== undefined) {
                localVarQueryParameter['sales_point_id'] = sales_point_id;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CodiOperationsFiltersRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.OperacionesCoDiApiFetchParamCreator = OperacionesCoDiApiFetchParamCreator;
/**
 * OperacionesCoDiApi - functional programming interface
 * @export
 */
const OperacionesCoDiApiFp = function (configuration) {
    return {
        /**
         * Obtiene las operaciones generadas a partir de peticiones de pago CODI® de forma paginada, pudiendo aplicar filtros.
         * @summary Consulta de operaciones
         * @param {CodiOperationsFiltersRequestDTO} [body] Filtros de busqueda
         * @param {string} authorization Header para token
         * @param {string} [company_id] Es el identificador de empresa CODI®.
         * @param {string} [page] Es el número de pago.
         * @param {string} [sales_point_id] Es el identificador del punto de venta.
         * @param {string} [size] Es el tamaño de página.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consultCodiOperations(body, authorization, company_id, page, sales_point_id, size, options) {
            const localVarFetchArgs = (0, exports.OperacionesCoDiApiFetchParamCreator)(configuration).consultCodiOperations(body, authorization, company_id, page, sales_point_id, size, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.OperacionesCoDiApiFp = OperacionesCoDiApiFp;
/**
 * OperacionesCoDiApi - factory interface
 * @export
 */
const OperacionesCoDiApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene las operaciones generadas a partir de peticiones de pago CODI® de forma paginada, pudiendo aplicar filtros.
         * @summary Consulta de operaciones
         * @param {CodiOperationsFiltersRequestDTO} [body] Filtros de busqueda
         * @param {string} authorization Header para token
         * @param {string} [company_id] Es el identificador de empresa CODI®.
         * @param {string} [page] Es el número de pago.
         * @param {string} [sales_point_id] Es el identificador del punto de venta.
         * @param {string} [size] Es el tamaño de página.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consultCodiOperations(body, authorization, company_id, page, sales_point_id, size, options) {
            return (0, exports.OperacionesCoDiApiFp)(configuration).consultCodiOperations(body, authorization, company_id, page, sales_point_id, size, options)(fetch, basePath);
        },
    };
};
exports.OperacionesCoDiApiFactory = OperacionesCoDiApiFactory;
/**
 * OperacionesCoDiApi - object-oriented interface
 * @export
 * @class OperacionesCoDiApi
 * @extends {BaseAPI}
 */
class OperacionesCoDiApi extends BaseAPI {
    /**
     * Obtiene las operaciones generadas a partir de peticiones de pago CODI® de forma paginada, pudiendo aplicar filtros.
     * @summary Consulta de operaciones
     * @param {CodiOperationsFiltersRequestDTO} [body] Filtros de busqueda
     * @param {string} authorization Header para token
     * @param {string} [company_id] Es el identificador de empresa CODI®.
     * @param {string} [page] Es el número de pago.
     * @param {string} [sales_point_id] Es el identificador del punto de venta.
     * @param {string} [size] Es el tamaño de página.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperacionesCoDiApi
     */
    consultCodiOperations(body, authorization, company_id, page, sales_point_id, size, options) {
        return (0, exports.OperacionesCoDiApiFp)(this.configuration).consultCodiOperations(body, authorization, company_id, page, sales_point_id, size, options)(this.fetch, this.basePath);
    }
}
exports.OperacionesCoDiApi = OperacionesCoDiApi;
/**
 * PeticionesDePagoPorCoDiApi - fetch parameter creator
 * @export
 */
const PeticionesDePagoPorCoDiApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene la información de una petición de pago CODI® por orderId para un punto de venta.
         * @summary Consulta información de petición por orderId
         * @param {string} authorization Header para token
         * @param {string} order_id Identificador del pago CODI®
         * @param {string} sales_point_id Identificador del punto de venta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consultCodiRequestByOrderId(authorization, order_id, sales_point_id, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling consultCodiRequestByOrderId.');
            }
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id', 'Required parameter order_id was null or undefined when calling consultCodiRequestByOrderId.');
            }
            // verify required parameter 'sales_point_id' is not null or undefined
            if (sales_point_id === null || sales_point_id === undefined) {
                throw new RequiredError('sales_point_id', 'Required parameter sales_point_id was null or undefined when calling consultCodiRequestByOrderId.');
            }
            const localVarPath = `/codi/sales-point/charges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (order_id !== undefined) {
                localVarQueryParameter['orderId'] = order_id;
            }
            if (sales_point_id !== undefined) {
                localVarQueryParameter['salesPointId'] = sales_point_id;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Genera un código QR solicitado por un punto de venta para un pago mediante CODI®
         * @summary Genera código QR
         * @param {CodiCodeRequestDTO} body Información del pago CODI®
         * @param {string} authorization Header para token
         * @param {string} sales_point_id Identificador del punto de venta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCodiCodeQR(body, authorization, sales_point_id, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling generateCodiCodeQR.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling generateCodiCodeQR.');
            }
            // verify required parameter 'sales_point_id' is not null or undefined
            if (sales_point_id === null || sales_point_id === undefined) {
                throw new RequiredError('sales_point_id', 'Required parameter sales_point_id was null or undefined when calling generateCodiCodeQR.');
            }
            const localVarPath = `/codi/sales-point/charges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (sales_point_id !== undefined) {
                localVarQueryParameter['salesPointId'] = sales_point_id;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CodiCodeRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PeticionesDePagoPorCoDiApiFetchParamCreator = PeticionesDePagoPorCoDiApiFetchParamCreator;
/**
 * PeticionesDePagoPorCoDiApi - functional programming interface
 * @export
 */
const PeticionesDePagoPorCoDiApiFp = function (configuration) {
    return {
        /**
         * Obtiene la información de una petición de pago CODI® por orderId para un punto de venta.
         * @summary Consulta información de petición por orderId
         * @param {string} authorization Header para token
         * @param {string} order_id Identificador del pago CODI®
         * @param {string} sales_point_id Identificador del punto de venta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consultCodiRequestByOrderId(authorization, order_id, sales_point_id, options) {
            const localVarFetchArgs = (0, exports.PeticionesDePagoPorCoDiApiFetchParamCreator)(configuration).consultCodiRequestByOrderId(authorization, order_id, sales_point_id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Genera un código QR solicitado por un punto de venta para un pago mediante CODI®
         * @summary Genera código QR
         * @param {CodiCodeRequestDTO} body Información del pago CODI®
         * @param {string} authorization Header para token
         * @param {string} sales_point_id Identificador del punto de venta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCodiCodeQR(body, authorization, sales_point_id, options) {
            const localVarFetchArgs = (0, exports.PeticionesDePagoPorCoDiApiFetchParamCreator)(configuration).generateCodiCodeQR(body, authorization, sales_point_id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.PeticionesDePagoPorCoDiApiFp = PeticionesDePagoPorCoDiApiFp;
/**
 * PeticionesDePagoPorCoDiApi - factory interface
 * @export
 */
const PeticionesDePagoPorCoDiApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene la información de una petición de pago CODI® por orderId para un punto de venta.
         * @summary Consulta información de petición por orderId
         * @param {string} authorization Header para token
         * @param {string} order_id Identificador del pago CODI®
         * @param {string} sales_point_id Identificador del punto de venta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consultCodiRequestByOrderId(authorization, order_id, sales_point_id, options) {
            return (0, exports.PeticionesDePagoPorCoDiApiFp)(configuration).consultCodiRequestByOrderId(authorization, order_id, sales_point_id, options)(fetch, basePath);
        },
        /**
         * Genera un código QR solicitado por un punto de venta para un pago mediante CODI®
         * @summary Genera código QR
         * @param {CodiCodeRequestDTO} body Información del pago CODI®
         * @param {string} authorization Header para token
         * @param {string} sales_point_id Identificador del punto de venta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCodiCodeQR(body, authorization, sales_point_id, options) {
            return (0, exports.PeticionesDePagoPorCoDiApiFp)(configuration).generateCodiCodeQR(body, authorization, sales_point_id, options)(fetch, basePath);
        },
    };
};
exports.PeticionesDePagoPorCoDiApiFactory = PeticionesDePagoPorCoDiApiFactory;
/**
 * PeticionesDePagoPorCoDiApi - object-oriented interface
 * @export
 * @class PeticionesDePagoPorCoDiApi
 * @extends {BaseAPI}
 */
class PeticionesDePagoPorCoDiApi extends BaseAPI {
    /**
     * Obtiene la información de una petición de pago CODI® por orderId para un punto de venta.
     * @summary Consulta información de petición por orderId
     * @param {string} authorization Header para token
     * @param {string} order_id Identificador del pago CODI®
     * @param {string} sales_point_id Identificador del punto de venta
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeticionesDePagoPorCoDiApi
     */
    consultCodiRequestByOrderId(authorization, order_id, sales_point_id, options) {
        return (0, exports.PeticionesDePagoPorCoDiApiFp)(this.configuration).consultCodiRequestByOrderId(authorization, order_id, sales_point_id, options)(this.fetch, this.basePath);
    }
    /**
     * Genera un código QR solicitado por un punto de venta para un pago mediante CODI®
     * @summary Genera código QR
     * @param {CodiCodeRequestDTO} body Información del pago CODI®
     * @param {string} authorization Header para token
     * @param {string} sales_point_id Identificador del punto de venta
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeticionesDePagoPorCoDiApi
     */
    generateCodiCodeQR(body, authorization, sales_point_id, options) {
        return (0, exports.PeticionesDePagoPorCoDiApiFp)(this.configuration).generateCodiCodeQR(body, authorization, sales_point_id, options)(this.fetch, this.basePath);
    }
}
exports.PeticionesDePagoPorCoDiApi = PeticionesDePagoPorCoDiApi;
/**
 * PuntosDeVentaCoDiApi - fetch parameter creator
 * @export
 */
const PuntosDeVentaCoDiApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Se registra un punto de venta (TPV) desde donde se emitarán los cobros CODI®. El punto de venta se debe asociar a un cuenta CLABE registrada previamente ante Banxico para realizar cobros con CODI®.
         * @summary Registro de punto de venta.
         * @param {SalesPointRequest} body Es el objeto que contiene información del punto de venta CODI®.
         * @param {string} authorization Header para token
         * @param {string} company_id Es el identificador de la empresa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSalesPoint(body, authorization, company_id, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createSalesPoint.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling createSalesPoint.');
            }
            // verify required parameter 'company_id' is not null or undefined
            if (company_id === null || company_id === undefined) {
                throw new RequiredError('company_id', 'Required parameter company_id was null or undefined when calling createSalesPoint.');
            }
            const localVarPath = `/codi/companies/salespoint`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (company_id !== undefined) {
                localVarQueryParameter['companyId'] = company_id;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SalesPointRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene los puntos de venta asociados a una empresa en las cuales se hacen operaciones CODI®.
         * @summary Consulta de puntos de venta
         * @param {string} authorization Header para token
         * @param {string} company_id Es el identificador de la empresa. Ejemplo: 8838d513-5916-4662-bb30-2448f0f543ed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainSalePoints(authorization, company_id, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling obtainSalePoints.');
            }
            // verify required parameter 'company_id' is not null or undefined
            if (company_id === null || company_id === undefined) {
                throw new RequiredError('company_id', 'Required parameter company_id was null or undefined when calling obtainSalePoints.');
            }
            const localVarPath = `/codi/companies/salespoint`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (company_id !== undefined) {
                localVarQueryParameter['companyId'] = company_id;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PuntosDeVentaCoDiApiFetchParamCreator = PuntosDeVentaCoDiApiFetchParamCreator;
/**
 * PuntosDeVentaCoDiApi - functional programming interface
 * @export
 */
const PuntosDeVentaCoDiApiFp = function (configuration) {
    return {
        /**
         * Se registra un punto de venta (TPV) desde donde se emitarán los cobros CODI®. El punto de venta se debe asociar a un cuenta CLABE registrada previamente ante Banxico para realizar cobros con CODI®.
         * @summary Registro de punto de venta.
         * @param {SalesPointRequest} body Es el objeto que contiene información del punto de venta CODI®.
         * @param {string} authorization Header para token
         * @param {string} company_id Es el identificador de la empresa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSalesPoint(body, authorization, company_id, options) {
            const localVarFetchArgs = (0, exports.PuntosDeVentaCoDiApiFetchParamCreator)(configuration).createSalesPoint(body, authorization, company_id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtiene los puntos de venta asociados a una empresa en las cuales se hacen operaciones CODI®.
         * @summary Consulta de puntos de venta
         * @param {string} authorization Header para token
         * @param {string} company_id Es el identificador de la empresa. Ejemplo: 8838d513-5916-4662-bb30-2448f0f543ed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainSalePoints(authorization, company_id, options) {
            const localVarFetchArgs = (0, exports.PuntosDeVentaCoDiApiFetchParamCreator)(configuration).obtainSalePoints(authorization, company_id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.PuntosDeVentaCoDiApiFp = PuntosDeVentaCoDiApiFp;
/**
 * PuntosDeVentaCoDiApi - factory interface
 * @export
 */
const PuntosDeVentaCoDiApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Se registra un punto de venta (TPV) desde donde se emitarán los cobros CODI®. El punto de venta se debe asociar a un cuenta CLABE registrada previamente ante Banxico para realizar cobros con CODI®.
         * @summary Registro de punto de venta.
         * @param {SalesPointRequest} body Es el objeto que contiene información del punto de venta CODI®.
         * @param {string} authorization Header para token
         * @param {string} company_id Es el identificador de la empresa.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSalesPoint(body, authorization, company_id, options) {
            return (0, exports.PuntosDeVentaCoDiApiFp)(configuration).createSalesPoint(body, authorization, company_id, options)(fetch, basePath);
        },
        /**
         * Obtiene los puntos de venta asociados a una empresa en las cuales se hacen operaciones CODI®.
         * @summary Consulta de puntos de venta
         * @param {string} authorization Header para token
         * @param {string} company_id Es el identificador de la empresa. Ejemplo: 8838d513-5916-4662-bb30-2448f0f543ed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtainSalePoints(authorization, company_id, options) {
            return (0, exports.PuntosDeVentaCoDiApiFp)(configuration).obtainSalePoints(authorization, company_id, options)(fetch, basePath);
        },
    };
};
exports.PuntosDeVentaCoDiApiFactory = PuntosDeVentaCoDiApiFactory;
/**
 * PuntosDeVentaCoDiApi - object-oriented interface
 * @export
 * @class PuntosDeVentaCoDiApi
 * @extends {BaseAPI}
 */
class PuntosDeVentaCoDiApi extends BaseAPI {
    /**
     * Se registra un punto de venta (TPV) desde donde se emitarán los cobros CODI®. El punto de venta se debe asociar a un cuenta CLABE registrada previamente ante Banxico para realizar cobros con CODI®.
     * @summary Registro de punto de venta.
     * @param {SalesPointRequest} body Es el objeto que contiene información del punto de venta CODI®.
     * @param {string} authorization Header para token
     * @param {string} company_id Es el identificador de la empresa.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PuntosDeVentaCoDiApi
     */
    createSalesPoint(body, authorization, company_id, options) {
        return (0, exports.PuntosDeVentaCoDiApiFp)(this.configuration).createSalesPoint(body, authorization, company_id, options)(this.fetch, this.basePath);
    }
    /**
     * Obtiene los puntos de venta asociados a una empresa en las cuales se hacen operaciones CODI®.
     * @summary Consulta de puntos de venta
     * @param {string} authorization Header para token
     * @param {string} company_id Es el identificador de la empresa. Ejemplo: 8838d513-5916-4662-bb30-2448f0f543ed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PuntosDeVentaCoDiApi
     */
    obtainSalePoints(authorization, company_id, options) {
        return (0, exports.PuntosDeVentaCoDiApiFp)(this.configuration).obtainSalePoints(authorization, company_id, options)(this.fetch, this.basePath);
    }
}
exports.PuntosDeVentaCoDiApi = PuntosDeVentaCoDiApi;
/**
 * SaldoApi - fetch parameter creator
 * @export
 */
const SaldoApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene el saldo de un contrato, según las divisas que se manejen en dicho contrato, ya sea peso mexicano (MXP) o dólar estadounidense (USD).
         * @summary Consulta los saldo de una cuenta
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceUsingGET(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getBalanceUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getBalanceUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/balance`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SaldoApiFetchParamCreator = SaldoApiFetchParamCreator;
/**
 * SaldoApi - functional programming interface
 * @export
 */
const SaldoApiFp = function (configuration) {
    return {
        /**
         * Obtiene el saldo de un contrato, según las divisas que se manejen en dicho contrato, ya sea peso mexicano (MXP) o dólar estadounidense (USD).
         * @summary Consulta los saldo de una cuenta
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceUsingGET(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.SaldoApiFetchParamCreator)(configuration).getBalanceUsingGET(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.SaldoApiFp = SaldoApiFp;
/**
 * SaldoApi - factory interface
 * @export
 */
const SaldoApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene el saldo de un contrato, según las divisas que se manejen en dicho contrato, ya sea peso mexicano (MXP) o dólar estadounidense (USD).
         * @summary Consulta los saldo de una cuenta
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceUsingGET(authorization, subscription, options) {
            return (0, exports.SaldoApiFp)(configuration).getBalanceUsingGET(authorization, subscription, options)(fetch, basePath);
        },
    };
};
exports.SaldoApiFactory = SaldoApiFactory;
/**
 * SaldoApi - object-oriented interface
 * @export
 * @class SaldoApi
 * @extends {BaseAPI}
 */
class SaldoApi extends BaseAPI {
    /**
     * Obtiene el saldo de un contrato, según las divisas que se manejen en dicho contrato, ya sea peso mexicano (MXP) o dólar estadounidense (USD).
     * @summary Consulta los saldo de una cuenta
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaldoApi
     */
    getBalanceUsingGET(authorization, subscription, options) {
        return (0, exports.SaldoApiFp)(this.configuration).getBalanceUsingGET(authorization, subscription, options)(this.fetch, this.basePath);
    }
}
exports.SaldoApi = SaldoApi;
/**
 * SuscripcionesApi - fetch parameter creator
 * @export
 */
const SuscripcionesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Se cambia el estado o estatus de la suscripción a los posibles valores que son: ACTIVE o INACTIVE
         * @summary Cambia el estatus de la suscripción
         * @param {SubscriptionChangeStatusRequest} body request
         * @param {string} authorization Header para token
         * @param {string} subscription subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionStatusUsingPUT(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling changeSubscriptionStatusUsingPUT.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling changeSubscriptionStatusUsingPUT.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling changeSubscriptionStatusUsingPUT.');
            }
            const localVarPath = `/subscriptions/{subscription}/status`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SubscriptionChangeStatusRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se asigna o cambia el uso y el estatus que se le dará a la subscripción para los servicios SPEI y SPID en el manejo de Cobros y Pagos El status puede tener los posibles valores: ACTIVE o INACTIVE. El uso puede tener los posibles valores: WITHDRAWAL_DEPOSIT o WITHDRAWAL o DEPOSIT
         * @summary Cambia el uso de la suscripción
         * @param {ServiceBanking} body request
         * @param {string} authorization Header para token
         * @param {string} subscription subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionUseUsingPATCH(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling changeSubscriptionUseUsingPATCH.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling changeSubscriptionUseUsingPATCH.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling changeSubscriptionUseUsingPATCH.');
            }
            const localVarPath = `/subscriptions/{subscription}`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ServiceBanking" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pre-registra una suscripción para operar un contrato a través de un aplicación socio de la plataforma. Se retorna una dirección URL hacia el centro de autorización donde el cliente  Monex debe autorizar el acceso a los datos de su cuenta a el socio.<br/><br/>Una vez que el cuentahabiente autorice el acceso, se envía una notificación (webhook configurado) con el evento 'ENROLLMENT.CREATED', el cuál contiene los datos de acceso a esta API.
         * @summary Pre-registro de una suscripción
         * @param {PreEnrollmentData} body Información para la pre-suscripción
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preEnrollmentMonexUserUsingPOST(body, authorization, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling preEnrollmentMonexUserUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling preEnrollmentMonexUserUsingPOST.');
            }
            const localVarPath = `/subscriptions/pre-subscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PreEnrollmentData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina una suscripción mediante su identificador. Una vez eliminada dicha suscripción, ya no se podrán realizar operaciones en el API utilizando sus credenciales
         * @summary Elimina suscripción por su identificador.
         * @param {string} authorization Header para token
         * @param {string} subscription El identificador de la suscripción a ésta API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEnrollmentUserUsingDELETE(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling removeEnrollmentUserUsingDELETE.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling removeEnrollmentUserUsingDELETE.');
            }
            const localVarPath = `/subscriptions/{subscription}`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se elimina el pre-registro de suscripción. Sólo se elimina en caso de que el cliente Monex no haya concedido su autorización de acceso (token), es decir que la suscripcion esté pendiente.
         * @summary Elimina pre-registro de suscripción
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionPendingStatusUsingDELETE(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling removeSubscriptionPendingStatusUsingDELETE.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling removeSubscriptionPendingStatusUsingDELETE.');
            }
            const localVarPath = `/subscriptions/pre-subscription/{subscription}`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SuscripcionesApiFetchParamCreator = SuscripcionesApiFetchParamCreator;
/**
 * SuscripcionesApi - functional programming interface
 * @export
 */
const SuscripcionesApiFp = function (configuration) {
    return {
        /**
         * Se cambia el estado o estatus de la suscripción a los posibles valores que son: ACTIVE o INACTIVE
         * @summary Cambia el estatus de la suscripción
         * @param {SubscriptionChangeStatusRequest} body request
         * @param {string} authorization Header para token
         * @param {string} subscription subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionStatusUsingPUT(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.SuscripcionesApiFetchParamCreator)(configuration).changeSubscriptionStatusUsingPUT(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Se asigna o cambia el uso y el estatus que se le dará a la subscripción para los servicios SPEI y SPID en el manejo de Cobros y Pagos El status puede tener los posibles valores: ACTIVE o INACTIVE. El uso puede tener los posibles valores: WITHDRAWAL_DEPOSIT o WITHDRAWAL o DEPOSIT
         * @summary Cambia el uso de la suscripción
         * @param {ServiceBanking} body request
         * @param {string} authorization Header para token
         * @param {string} subscription subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionUseUsingPATCH(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.SuscripcionesApiFetchParamCreator)(configuration).changeSubscriptionUseUsingPATCH(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pre-registra una suscripción para operar un contrato a través de un aplicación socio de la plataforma. Se retorna una dirección URL hacia el centro de autorización donde el cliente  Monex debe autorizar el acceso a los datos de su cuenta a el socio.<br/><br/>Una vez que el cuentahabiente autorice el acceso, se envía una notificación (webhook configurado) con el evento 'ENROLLMENT.CREATED', el cuál contiene los datos de acceso a esta API.
         * @summary Pre-registro de una suscripción
         * @param {PreEnrollmentData} body Información para la pre-suscripción
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preEnrollmentMonexUserUsingPOST(body, authorization, options) {
            const localVarFetchArgs = (0, exports.SuscripcionesApiFetchParamCreator)(configuration).preEnrollmentMonexUserUsingPOST(body, authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Elimina una suscripción mediante su identificador. Una vez eliminada dicha suscripción, ya no se podrán realizar operaciones en el API utilizando sus credenciales
         * @summary Elimina suscripción por su identificador.
         * @param {string} authorization Header para token
         * @param {string} subscription El identificador de la suscripción a ésta API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEnrollmentUserUsingDELETE(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.SuscripcionesApiFetchParamCreator)(configuration).removeEnrollmentUserUsingDELETE(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Se elimina el pre-registro de suscripción. Sólo se elimina en caso de que el cliente Monex no haya concedido su autorización de acceso (token), es decir que la suscripcion esté pendiente.
         * @summary Elimina pre-registro de suscripción
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionPendingStatusUsingDELETE(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.SuscripcionesApiFetchParamCreator)(configuration).removeSubscriptionPendingStatusUsingDELETE(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.SuscripcionesApiFp = SuscripcionesApiFp;
/**
 * SuscripcionesApi - factory interface
 * @export
 */
const SuscripcionesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Se cambia el estado o estatus de la suscripción a los posibles valores que son: ACTIVE o INACTIVE
         * @summary Cambia el estatus de la suscripción
         * @param {SubscriptionChangeStatusRequest} body request
         * @param {string} authorization Header para token
         * @param {string} subscription subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionStatusUsingPUT(body, authorization, subscription, options) {
            return (0, exports.SuscripcionesApiFp)(configuration).changeSubscriptionStatusUsingPUT(body, authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Se asigna o cambia el uso y el estatus que se le dará a la subscripción para los servicios SPEI y SPID en el manejo de Cobros y Pagos El status puede tener los posibles valores: ACTIVE o INACTIVE. El uso puede tener los posibles valores: WITHDRAWAL_DEPOSIT o WITHDRAWAL o DEPOSIT
         * @summary Cambia el uso de la suscripción
         * @param {ServiceBanking} body request
         * @param {string} authorization Header para token
         * @param {string} subscription subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionUseUsingPATCH(body, authorization, subscription, options) {
            return (0, exports.SuscripcionesApiFp)(configuration).changeSubscriptionUseUsingPATCH(body, authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Pre-registra una suscripción para operar un contrato a través de un aplicación socio de la plataforma. Se retorna una dirección URL hacia el centro de autorización donde el cliente  Monex debe autorizar el acceso a los datos de su cuenta a el socio.<br/><br/>Una vez que el cuentahabiente autorice el acceso, se envía una notificación (webhook configurado) con el evento 'ENROLLMENT.CREATED', el cuál contiene los datos de acceso a esta API.
         * @summary Pre-registro de una suscripción
         * @param {PreEnrollmentData} body Información para la pre-suscripción
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preEnrollmentMonexUserUsingPOST(body, authorization, options) {
            return (0, exports.SuscripcionesApiFp)(configuration).preEnrollmentMonexUserUsingPOST(body, authorization, options)(fetch, basePath);
        },
        /**
         * Elimina una suscripción mediante su identificador. Una vez eliminada dicha suscripción, ya no se podrán realizar operaciones en el API utilizando sus credenciales
         * @summary Elimina suscripción por su identificador.
         * @param {string} authorization Header para token
         * @param {string} subscription El identificador de la suscripción a ésta API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEnrollmentUserUsingDELETE(authorization, subscription, options) {
            return (0, exports.SuscripcionesApiFp)(configuration).removeEnrollmentUserUsingDELETE(authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Se elimina el pre-registro de suscripción. Sólo se elimina en caso de que el cliente Monex no haya concedido su autorización de acceso (token), es decir que la suscripcion esté pendiente.
         * @summary Elimina pre-registro de suscripción
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionPendingStatusUsingDELETE(authorization, subscription, options) {
            return (0, exports.SuscripcionesApiFp)(configuration).removeSubscriptionPendingStatusUsingDELETE(authorization, subscription, options)(fetch, basePath);
        },
    };
};
exports.SuscripcionesApiFactory = SuscripcionesApiFactory;
/**
 * SuscripcionesApi - object-oriented interface
 * @export
 * @class SuscripcionesApi
 * @extends {BaseAPI}
 */
class SuscripcionesApi extends BaseAPI {
    /**
     * Se cambia el estado o estatus de la suscripción a los posibles valores que son: ACTIVE o INACTIVE
     * @summary Cambia el estatus de la suscripción
     * @param {SubscriptionChangeStatusRequest} body request
     * @param {string} authorization Header para token
     * @param {string} subscription subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuscripcionesApi
     */
    changeSubscriptionStatusUsingPUT(body, authorization, subscription, options) {
        return (0, exports.SuscripcionesApiFp)(this.configuration).changeSubscriptionStatusUsingPUT(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Se asigna o cambia el uso y el estatus que se le dará a la subscripción para los servicios SPEI y SPID en el manejo de Cobros y Pagos El status puede tener los posibles valores: ACTIVE o INACTIVE. El uso puede tener los posibles valores: WITHDRAWAL_DEPOSIT o WITHDRAWAL o DEPOSIT
     * @summary Cambia el uso de la suscripción
     * @param {ServiceBanking} body request
     * @param {string} authorization Header para token
     * @param {string} subscription subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuscripcionesApi
     */
    changeSubscriptionUseUsingPATCH(body, authorization, subscription, options) {
        return (0, exports.SuscripcionesApiFp)(this.configuration).changeSubscriptionUseUsingPATCH(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Pre-registra una suscripción para operar un contrato a través de un aplicación socio de la plataforma. Se retorna una dirección URL hacia el centro de autorización donde el cliente  Monex debe autorizar el acceso a los datos de su cuenta a el socio.<br/><br/>Una vez que el cuentahabiente autorice el acceso, se envía una notificación (webhook configurado) con el evento 'ENROLLMENT.CREATED', el cuál contiene los datos de acceso a esta API.
     * @summary Pre-registro de una suscripción
     * @param {PreEnrollmentData} body Información para la pre-suscripción
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuscripcionesApi
     */
    preEnrollmentMonexUserUsingPOST(body, authorization, options) {
        return (0, exports.SuscripcionesApiFp)(this.configuration).preEnrollmentMonexUserUsingPOST(body, authorization, options)(this.fetch, this.basePath);
    }
    /**
     * Elimina una suscripción mediante su identificador. Una vez eliminada dicha suscripción, ya no se podrán realizar operaciones en el API utilizando sus credenciales
     * @summary Elimina suscripción por su identificador.
     * @param {string} authorization Header para token
     * @param {string} subscription El identificador de la suscripción a ésta API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuscripcionesApi
     */
    removeEnrollmentUserUsingDELETE(authorization, subscription, options) {
        return (0, exports.SuscripcionesApiFp)(this.configuration).removeEnrollmentUserUsingDELETE(authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Se elimina el pre-registro de suscripción. Sólo se elimina en caso de que el cliente Monex no haya concedido su autorización de acceso (token), es decir que la suscripcion esté pendiente.
     * @summary Elimina pre-registro de suscripción
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuscripcionesApi
     */
    removeSubscriptionPendingStatusUsingDELETE(authorization, subscription, options) {
        return (0, exports.SuscripcionesApiFp)(this.configuration).removeSubscriptionPendingStatusUsingDELETE(authorization, subscription, options)(this.fetch, this.basePath);
    }
}
exports.SuscripcionesApi = SuscripcionesApi;
/**
 * TransferenciasSPEIApi - fetch parameter creator
 * @export
 */
const TransferenciasSPEIApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Agrupa transacciones SPEI/SPID en un mismo transaction_id, posteriormente genera la dirección URL del centro de autorización para la confirmación de las transacciones. <br><br>Las transacciones deben estar en estatus PENDING y pertenecer a un mismo contrato.
         * @summary Agrupa transacciones bajo un request_id
         * @param {AuthorizationTransactionGroup} body Objeto con la información para agrupar transacciones existentes y autorizarlas de forma conjunta.
         * @param {string} authorization Header para token
         * @param {string} subscription Es el Identificador de la suscripción.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorizationTransactionsGroup(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createAuthorizationTransactionsGroup.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling createAuthorizationTransactionsGroup.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling createAuthorizationTransactionsGroup.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/group`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AuthorizationTransactionGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un conjunto de transferencias en estado pendiente de confirmar o autorizar, en la cuenta del cliente Monex relacionada a la suscripción.<br><br><b>Nota:</b> Las transferencias no deben haber sido confirmadas o autorizadas por el cliente.
         * @summary Eliminación de transferencias SPEI® pendientes
         * @param {string} authorization Header para token
         * @param {string} [order_id] Listado de identificadores dentro del request_id para eliminar.
         * @param {string} request_id Identificador de las transferencias a eliminar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTransactionsPendingUsingDELETE(authorization, order_id, request_id, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling dropTransactionsPendingUsingDELETE.');
            }
            // verify required parameter 'request_id' is not null or undefined
            if (request_id === null || request_id === undefined) {
                throw new RequiredError('request_id', 'Required parameter request_id was null or undefined when calling dropTransactionsPendingUsingDELETE.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling dropTransactionsPendingUsingDELETE.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming/spei/request/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(request_id)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (order_id !== undefined) {
                localVarQueryParameter['order_id'] = order_id;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realiza una consulta de las transferencias recibidas (depósitos) en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias  recibidas durante el día en el que se realiza la consulta. Para consultar transacciones que se encuentran en otras fechas se debe utilizar los parámetros de fecha inicial (beginDate) y fecha final (endDate), siempre deben de ir las dos ya que en caso de que falte una marcará error la consulta, si faltan las dos la consulta lanzará solo las del día, como se describe al inicio. El formato para las fechas es \"yyyy-MM-dd\"
         * @summary Consulta de transferencias recibidas
         * @param {string} authorization Header para token
         * @param {string} [begin_date] Fecha inicial para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
         * @param {string} [end_date] Fecha final para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incomingSpeiTransactionsReportUsingGET(authorization, begin_date, end_date, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling incomingSpeiTransactionsReportUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling incomingSpeiTransactionsReportUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/incoming/spei`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (begin_date !== undefined) {
                localVarQueryParameter['beginDate'] = begin_date;
            }
            if (end_date !== undefined) {
                localVarQueryParameter['endDate'] = end_date;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
         * @summary Consulta de transferencias de salida por identificador de petición
         * @param {string} authorization Header para token
         * @param {string} request_id Identificador de la petición a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling outCommingSpeiRequestIdTransactionsReportUsingGET.');
            }
            // verify required parameter 'request_id' is not null or undefined
            if (request_id === null || request_id === undefined) {
                throw new RequiredError('request_id', 'Required parameter request_id was null or undefined when calling outCommingSpeiRequestIdTransactionsReportUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling outCommingSpeiRequestIdTransactionsReportUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming/spei/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(request_id)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consulta las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta o las transferencias identificadas con el <strong>order_id</strong> proporcionado, para este tipo de consultas no importa el día en el que se realizó la transferencia. <br> Es importante que conozca que la respuesta puede dar como resultado un objeto con una lista spei o una lista spid con el/los elementos ya que un identificador order_id solo puede pertenecer a una transacción sea spei o spid.
         * @summary Consulta de transferencias realizadas por order_id
         * @param {string} authorization Header para token
         * @param {string} [order_id] Es el identificador de la orden a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiSpidOrderIdTransactionReportUsingGET(authorization, order_id, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling outCommingSpeiSpidOrderIdTransactionReportUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling outCommingSpeiSpidOrderIdTransactionReportUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (order_id !== undefined) {
                localVarQueryParameter['order_id'] = order_id;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
         * @summary Consulta de transferencias de salida por identificador de petición
         * @param {string} authorization Header para token
         * @param {string} request_id Identificador de la petición a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiSpidRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling outCommingSpeiSpidRequestIdTransactionsReportUsingGET.');
            }
            // verify required parameter 'request_id' is not null or undefined
            if (request_id === null || request_id === undefined) {
                throw new RequiredError('request_id', 'Required parameter request_id was null or undefined when calling outCommingSpeiSpidRequestIdTransactionsReportUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling outCommingSpeiSpidRequestIdTransactionsReportUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(request_id)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consulta las transferencias realizadas en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta.<br>Se pueden realizar consultas por <strong>order_id</strong> al realizar este tipo de consultas no importa el día en el que se realizó la transferencia
         * @summary Consulta de transferencias realizadas
         * @param {string} authorization Header para token
         * @param {string} [order_id] Es el identificador de la orden a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outgoingSpeiTransactionsReportUsingGET(authorization, order_id, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling outgoingSpeiTransactionsReportUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling outgoingSpeiTransactionsReportUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming/spei`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (order_id !== undefined) {
                localVarQueryParameter['order_id'] = order_id;
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se registra un conjunto de transferencias (una o más) a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias
         * @param {TransactionsOutgoingRegister} body Información de las transferencias SPEI de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOutgoingSpeiTransactionUsingPOST(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerOutgoingSpeiTransactionUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling registerOutgoingSpeiTransactionUsingPOST.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling registerOutgoingSpeiTransactionUsingPOST.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming/spei`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TransactionsOutgoingRegister" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Se registra un conjunto de transferencias (una o más) tanto SPEI como SPID en una sola petición en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias SPEI y SPID
         * @param {TransactionsRegister} body Información de las transferencias SPEI y SPID de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSpeiSpidOutgoingTransactionsUsingPOST(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerSpeiSpidOutgoingTransactionsUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling registerSpeiSpidOutgoingTransactionsUsingPOST.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling registerSpeiSpidOutgoingTransactionsUsingPOST.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TransactionsRegister" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TransferenciasSPEIApiFetchParamCreator = TransferenciasSPEIApiFetchParamCreator;
/**
 * TransferenciasSPEIApi - functional programming interface
 * @export
 */
const TransferenciasSPEIApiFp = function (configuration) {
    return {
        /**
         * Agrupa transacciones SPEI/SPID en un mismo transaction_id, posteriormente genera la dirección URL del centro de autorización para la confirmación de las transacciones. <br><br>Las transacciones deben estar en estatus PENDING y pertenecer a un mismo contrato.
         * @summary Agrupa transacciones bajo un request_id
         * @param {AuthorizationTransactionGroup} body Objeto con la información para agrupar transacciones existentes y autorizarlas de forma conjunta.
         * @param {string} authorization Header para token
         * @param {string} subscription Es el Identificador de la suscripción.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorizationTransactionsGroup(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).createAuthorizationTransactionsGroup(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Elimina un conjunto de transferencias en estado pendiente de confirmar o autorizar, en la cuenta del cliente Monex relacionada a la suscripción.<br><br><b>Nota:</b> Las transferencias no deben haber sido confirmadas o autorizadas por el cliente.
         * @summary Eliminación de transferencias SPEI® pendientes
         * @param {string} authorization Header para token
         * @param {string} [order_id] Listado de identificadores dentro del request_id para eliminar.
         * @param {string} request_id Identificador de las transferencias a eliminar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTransactionsPendingUsingDELETE(authorization, order_id, request_id, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).dropTransactionsPendingUsingDELETE(authorization, order_id, request_id, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Realiza una consulta de las transferencias recibidas (depósitos) en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias  recibidas durante el día en el que se realiza la consulta. Para consultar transacciones que se encuentran en otras fechas se debe utilizar los parámetros de fecha inicial (beginDate) y fecha final (endDate), siempre deben de ir las dos ya que en caso de que falte una marcará error la consulta, si faltan las dos la consulta lanzará solo las del día, como se describe al inicio. El formato para las fechas es \"yyyy-MM-dd\"
         * @summary Consulta de transferencias recibidas
         * @param {string} authorization Header para token
         * @param {string} [begin_date] Fecha inicial para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
         * @param {string} [end_date] Fecha final para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incomingSpeiTransactionsReportUsingGET(authorization, begin_date, end_date, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).incomingSpeiTransactionsReportUsingGET(authorization, begin_date, end_date, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
         * @summary Consulta de transferencias de salida por identificador de petición
         * @param {string} authorization Header para token
         * @param {string} request_id Identificador de la petición a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).outCommingSpeiRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Consulta las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta o las transferencias identificadas con el <strong>order_id</strong> proporcionado, para este tipo de consultas no importa el día en el que se realizó la transferencia. <br> Es importante que conozca que la respuesta puede dar como resultado un objeto con una lista spei o una lista spid con el/los elementos ya que un identificador order_id solo puede pertenecer a una transacción sea spei o spid.
         * @summary Consulta de transferencias realizadas por order_id
         * @param {string} authorization Header para token
         * @param {string} [order_id] Es el identificador de la orden a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiSpidOrderIdTransactionReportUsingGET(authorization, order_id, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).outCommingSpeiSpidOrderIdTransactionReportUsingGET(authorization, order_id, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
         * @summary Consulta de transferencias de salida por identificador de petición
         * @param {string} authorization Header para token
         * @param {string} request_id Identificador de la petición a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiSpidRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).outCommingSpeiSpidRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Consulta las transferencias realizadas en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta.<br>Se pueden realizar consultas por <strong>order_id</strong> al realizar este tipo de consultas no importa el día en el que se realizó la transferencia
         * @summary Consulta de transferencias realizadas
         * @param {string} authorization Header para token
         * @param {string} [order_id] Es el identificador de la orden a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outgoingSpeiTransactionsReportUsingGET(authorization, order_id, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).outgoingSpeiTransactionsReportUsingGET(authorization, order_id, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Se registra un conjunto de transferencias (una o más) a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias
         * @param {TransactionsOutgoingRegister} body Información de las transferencias SPEI de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOutgoingSpeiTransactionUsingPOST(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).registerOutgoingSpeiTransactionUsingPOST(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Se registra un conjunto de transferencias (una o más) tanto SPEI como SPID en una sola petición en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias SPEI y SPID
         * @param {TransactionsRegister} body Información de las transferencias SPEI y SPID de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSpeiSpidOutgoingTransactionsUsingPOST(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPEIApiFetchParamCreator)(configuration).registerSpeiSpidOutgoingTransactionsUsingPOST(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TransferenciasSPEIApiFp = TransferenciasSPEIApiFp;
/**
 * TransferenciasSPEIApi - factory interface
 * @export
 */
const TransferenciasSPEIApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Agrupa transacciones SPEI/SPID en un mismo transaction_id, posteriormente genera la dirección URL del centro de autorización para la confirmación de las transacciones. <br><br>Las transacciones deben estar en estatus PENDING y pertenecer a un mismo contrato.
         * @summary Agrupa transacciones bajo un request_id
         * @param {AuthorizationTransactionGroup} body Objeto con la información para agrupar transacciones existentes y autorizarlas de forma conjunta.
         * @param {string} authorization Header para token
         * @param {string} subscription Es el Identificador de la suscripción.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorizationTransactionsGroup(body, authorization, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).createAuthorizationTransactionsGroup(body, authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Elimina un conjunto de transferencias en estado pendiente de confirmar o autorizar, en la cuenta del cliente Monex relacionada a la suscripción.<br><br><b>Nota:</b> Las transferencias no deben haber sido confirmadas o autorizadas por el cliente.
         * @summary Eliminación de transferencias SPEI® pendientes
         * @param {string} authorization Header para token
         * @param {string} [order_id] Listado de identificadores dentro del request_id para eliminar.
         * @param {string} request_id Identificador de las transferencias a eliminar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTransactionsPendingUsingDELETE(authorization, order_id, request_id, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).dropTransactionsPendingUsingDELETE(authorization, order_id, request_id, subscription, options)(fetch, basePath);
        },
        /**
         * Realiza una consulta de las transferencias recibidas (depósitos) en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias  recibidas durante el día en el que se realiza la consulta. Para consultar transacciones que se encuentran en otras fechas se debe utilizar los parámetros de fecha inicial (beginDate) y fecha final (endDate), siempre deben de ir las dos ya que en caso de que falte una marcará error la consulta, si faltan las dos la consulta lanzará solo las del día, como se describe al inicio. El formato para las fechas es \"yyyy-MM-dd\"
         * @summary Consulta de transferencias recibidas
         * @param {string} authorization Header para token
         * @param {string} [begin_date] Fecha inicial para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
         * @param {string} [end_date] Fecha final para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incomingSpeiTransactionsReportUsingGET(authorization, begin_date, end_date, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).incomingSpeiTransactionsReportUsingGET(authorization, begin_date, end_date, subscription, options)(fetch, basePath);
        },
        /**
         * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
         * @summary Consulta de transferencias de salida por identificador de petición
         * @param {string} authorization Header para token
         * @param {string} request_id Identificador de la petición a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).outCommingSpeiRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options)(fetch, basePath);
        },
        /**
         * Consulta las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta o las transferencias identificadas con el <strong>order_id</strong> proporcionado, para este tipo de consultas no importa el día en el que se realizó la transferencia. <br> Es importante que conozca que la respuesta puede dar como resultado un objeto con una lista spei o una lista spid con el/los elementos ya que un identificador order_id solo puede pertenecer a una transacción sea spei o spid.
         * @summary Consulta de transferencias realizadas por order_id
         * @param {string} authorization Header para token
         * @param {string} [order_id] Es el identificador de la orden a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiSpidOrderIdTransactionReportUsingGET(authorization, order_id, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).outCommingSpeiSpidOrderIdTransactionReportUsingGET(authorization, order_id, subscription, options)(fetch, basePath);
        },
        /**
         * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
         * @summary Consulta de transferencias de salida por identificador de petición
         * @param {string} authorization Header para token
         * @param {string} request_id Identificador de la petición a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outCommingSpeiSpidRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).outCommingSpeiSpidRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options)(fetch, basePath);
        },
        /**
         * Consulta las transferencias realizadas en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta.<br>Se pueden realizar consultas por <strong>order_id</strong> al realizar este tipo de consultas no importa el día en el que se realizó la transferencia
         * @summary Consulta de transferencias realizadas
         * @param {string} authorization Header para token
         * @param {string} [order_id] Es el identificador de la orden a buscar.
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outgoingSpeiTransactionsReportUsingGET(authorization, order_id, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).outgoingSpeiTransactionsReportUsingGET(authorization, order_id, subscription, options)(fetch, basePath);
        },
        /**
         * Se registra un conjunto de transferencias (una o más) a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias
         * @param {TransactionsOutgoingRegister} body Información de las transferencias SPEI de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOutgoingSpeiTransactionUsingPOST(body, authorization, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).registerOutgoingSpeiTransactionUsingPOST(body, authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Se registra un conjunto de transferencias (una o más) tanto SPEI como SPID en una sola petición en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias SPEI y SPID
         * @param {TransactionsRegister} body Información de las transferencias SPEI y SPID de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSpeiSpidOutgoingTransactionsUsingPOST(body, authorization, subscription, options) {
            return (0, exports.TransferenciasSPEIApiFp)(configuration).registerSpeiSpidOutgoingTransactionsUsingPOST(body, authorization, subscription, options)(fetch, basePath);
        },
    };
};
exports.TransferenciasSPEIApiFactory = TransferenciasSPEIApiFactory;
/**
 * TransferenciasSPEIApi - object-oriented interface
 * @export
 * @class TransferenciasSPEIApi
 * @extends {BaseAPI}
 */
class TransferenciasSPEIApi extends BaseAPI {
    /**
     * Agrupa transacciones SPEI/SPID en un mismo transaction_id, posteriormente genera la dirección URL del centro de autorización para la confirmación de las transacciones. <br><br>Las transacciones deben estar en estatus PENDING y pertenecer a un mismo contrato.
     * @summary Agrupa transacciones bajo un request_id
     * @param {AuthorizationTransactionGroup} body Objeto con la información para agrupar transacciones existentes y autorizarlas de forma conjunta.
     * @param {string} authorization Header para token
     * @param {string} subscription Es el Identificador de la suscripción.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    createAuthorizationTransactionsGroup(body, authorization, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).createAuthorizationTransactionsGroup(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Elimina un conjunto de transferencias en estado pendiente de confirmar o autorizar, en la cuenta del cliente Monex relacionada a la suscripción.<br><br><b>Nota:</b> Las transferencias no deben haber sido confirmadas o autorizadas por el cliente.
     * @summary Eliminación de transferencias SPEI® pendientes
     * @param {string} authorization Header para token
     * @param {string} [order_id] Listado de identificadores dentro del request_id para eliminar.
     * @param {string} request_id Identificador de las transferencias a eliminar.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    dropTransactionsPendingUsingDELETE(authorization, order_id, request_id, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).dropTransactionsPendingUsingDELETE(authorization, order_id, request_id, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Realiza una consulta de las transferencias recibidas (depósitos) en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias  recibidas durante el día en el que se realiza la consulta. Para consultar transacciones que se encuentran en otras fechas se debe utilizar los parámetros de fecha inicial (beginDate) y fecha final (endDate), siempre deben de ir las dos ya que en caso de que falte una marcará error la consulta, si faltan las dos la consulta lanzará solo las del día, como se describe al inicio. El formato para las fechas es \"yyyy-MM-dd\"
     * @summary Consulta de transferencias recibidas
     * @param {string} authorization Header para token
     * @param {string} [begin_date] Fecha inicial para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
     * @param {string} [end_date] Fecha final para filtrar los depósitos, se espera en formato &#x27;yyyy-MM-dd&#x27;
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    incomingSpeiTransactionsReportUsingGET(authorization, begin_date, end_date, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).incomingSpeiTransactionsReportUsingGET(authorization, begin_date, end_date, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
     * @summary Consulta de transferencias de salida por identificador de petición
     * @param {string} authorization Header para token
     * @param {string} request_id Identificador de la petición a buscar.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    outCommingSpeiRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).outCommingSpeiRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Consulta las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta o las transferencias identificadas con el <strong>order_id</strong> proporcionado, para este tipo de consultas no importa el día en el que se realizó la transferencia. <br> Es importante que conozca que la respuesta puede dar como resultado un objeto con una lista spei o una lista spid con el/los elementos ya que un identificador order_id solo puede pertenecer a una transacción sea spei o spid.
     * @summary Consulta de transferencias realizadas por order_id
     * @param {string} authorization Header para token
     * @param {string} [order_id] Es el identificador de la orden a buscar.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    outCommingSpeiSpidOrderIdTransactionReportUsingGET(authorization, order_id, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).outCommingSpeiSpidOrderIdTransactionReportUsingGET(authorization, order_id, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Consulta las transferencias de salida registradas en una petición, las transferencias que regresa este recuso son únicamente las transferencias de salida agrupadas al identificador de la petición que se generó al hacer el registro de las transacciones el cuál se debe especificar como parte del path de este endpoint.
     * @summary Consulta de transferencias de salida por identificador de petición
     * @param {string} authorization Header para token
     * @param {string} request_id Identificador de la petición a buscar.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    outCommingSpeiSpidRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).outCommingSpeiSpidRequestIdTransactionsReportUsingGET(authorization, request_id, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Consulta las transferencias realizadas en la cuenta del cliente Monex relacionada a la suscripción, las transferencias que regresa este recuso son únicamente las transferencias recibidas en el día en el que se realiza la consulta.<br>Se pueden realizar consultas por <strong>order_id</strong> al realizar este tipo de consultas no importa el día en el que se realizó la transferencia
     * @summary Consulta de transferencias realizadas
     * @param {string} authorization Header para token
     * @param {string} [order_id] Es el identificador de la orden a buscar.
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    outgoingSpeiTransactionsReportUsingGET(authorization, order_id, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).outgoingSpeiTransactionsReportUsingGET(authorization, order_id, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Se registra un conjunto de transferencias (una o más) a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
     * @summary Registro de transferencias
     * @param {TransactionsOutgoingRegister} body Información de las transferencias SPEI de salida
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    registerOutgoingSpeiTransactionUsingPOST(body, authorization, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).registerOutgoingSpeiTransactionUsingPOST(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Se registra un conjunto de transferencias (una o más) tanto SPEI como SPID en una sola petición en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br>  Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
     * @summary Registro de transferencias SPEI y SPID
     * @param {TransactionsRegister} body Información de las transferencias SPEI y SPID de salida
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPEIApi
     */
    registerSpeiSpidOutgoingTransactionsUsingPOST(body, authorization, subscription, options) {
        return (0, exports.TransferenciasSPEIApiFp)(this.configuration).registerSpeiSpidOutgoingTransactionsUsingPOST(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
}
exports.TransferenciasSPEIApi = TransferenciasSPEIApi;
/**
 * TransferenciasSPIDApi - fetch parameter creator
 * @export
 */
const TransferenciasSPIDApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene las clasificaciones para operaciones con dólares (SPID®) de Monex.<br/><br/>Este recurso se debe invocar previo al realizar una operación SPID.<br/><br/>
         * @summary Consulta de clasificaciones para operaciones SPID®
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpidClassificationsUsingGET(authorization, subscription, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getSpidClassificationsUsingGET.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling getSpidClassificationsUsingGET.');
            }
            const localVarPath = `/subscriptions/{subscription}/beneficiaries/spid/classifications`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra un conjunto de transferencias a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br> Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias SPID®
         * @param {TransactionOutgoingSpid} body Información de las transferencias SPID de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOutgoingSpidTransactionUsingPOST(body, authorization, subscription, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerOutgoingSpidTransactionUsingPOST.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling registerOutgoingSpidTransactionUsingPOST.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription', 'Required parameter subscription was null or undefined when calling registerOutgoingSpidTransactionUsingPOST.');
            }
            const localVarPath = `/subscriptions/{subscription}/transactions/outcoming/spid`
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TransactionOutgoingSpid" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TransferenciasSPIDApiFetchParamCreator = TransferenciasSPIDApiFetchParamCreator;
/**
 * TransferenciasSPIDApi - functional programming interface
 * @export
 */
const TransferenciasSPIDApiFp = function (configuration) {
    return {
        /**
         * Obtiene las clasificaciones para operaciones con dólares (SPID®) de Monex.<br/><br/>Este recurso se debe invocar previo al realizar una operación SPID.<br/><br/>
         * @summary Consulta de clasificaciones para operaciones SPID®
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpidClassificationsUsingGET(authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPIDApiFetchParamCreator)(configuration).getSpidClassificationsUsingGET(authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registra un conjunto de transferencias a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br> Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias SPID®
         * @param {TransactionOutgoingSpid} body Información de las transferencias SPID de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOutgoingSpidTransactionUsingPOST(body, authorization, subscription, options) {
            const localVarFetchArgs = (0, exports.TransferenciasSPIDApiFetchParamCreator)(configuration).registerOutgoingSpidTransactionUsingPOST(body, authorization, subscription, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TransferenciasSPIDApiFp = TransferenciasSPIDApiFp;
/**
 * TransferenciasSPIDApi - factory interface
 * @export
 */
const TransferenciasSPIDApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene las clasificaciones para operaciones con dólares (SPID®) de Monex.<br/><br/>Este recurso se debe invocar previo al realizar una operación SPID.<br/><br/>
         * @summary Consulta de clasificaciones para operaciones SPID®
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpidClassificationsUsingGET(authorization, subscription, options) {
            return (0, exports.TransferenciasSPIDApiFp)(configuration).getSpidClassificationsUsingGET(authorization, subscription, options)(fetch, basePath);
        },
        /**
         * Registra un conjunto de transferencias a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br> Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
         * @summary Registro de transferencias SPID®
         * @param {TransactionOutgoingSpid} body Información de las transferencias SPID de salida
         * @param {string} authorization Header para token
         * @param {string} subscription Es el identificador de la suscripción a esta API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOutgoingSpidTransactionUsingPOST(body, authorization, subscription, options) {
            return (0, exports.TransferenciasSPIDApiFp)(configuration).registerOutgoingSpidTransactionUsingPOST(body, authorization, subscription, options)(fetch, basePath);
        },
    };
};
exports.TransferenciasSPIDApiFactory = TransferenciasSPIDApiFactory;
/**
 * TransferenciasSPIDApi - object-oriented interface
 * @export
 * @class TransferenciasSPIDApi
 * @extends {BaseAPI}
 */
class TransferenciasSPIDApi extends BaseAPI {
    /**
     * Obtiene las clasificaciones para operaciones con dólares (SPID®) de Monex.<br/><br/>Este recurso se debe invocar previo al realizar una operación SPID.<br/><br/>
     * @summary Consulta de clasificaciones para operaciones SPID®
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPIDApi
     */
    getSpidClassificationsUsingGET(authorization, subscription, options) {
        return (0, exports.TransferenciasSPIDApiFp)(this.configuration).getSpidClassificationsUsingGET(authorization, subscription, options)(this.fetch, this.basePath);
    }
    /**
     * Registra un conjunto de transferencias a realizar en la cuenta del cliente Monex relacionada a la suscripción. En la respuesta se proporcionará una dirección URL que lo llevará al centro de autorización para que las transferencias sean confirmadas (autorizadas) por el cliente para que se efectúen, para ello debe ingresar la llave electrónica (Token).<br> Nota: Debe considerar que el concepto de cada una de las transacciones solo debe contener caracteres alfanuméricos por lo que en caso de que se reciban caracteres como ñ o acentos serán sustituidos por n o en su caso por la letra sin acento. Los caracteres no alfanuméricos como pueden ser caracteres especiales serán eliminados.
     * @summary Registro de transferencias SPID®
     * @param {TransactionOutgoingSpid} body Información de las transferencias SPID de salida
     * @param {string} authorization Header para token
     * @param {string} subscription Es el identificador de la suscripción a esta API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferenciasSPIDApi
     */
    registerOutgoingSpidTransactionUsingPOST(body, authorization, subscription, options) {
        return (0, exports.TransferenciasSPIDApiFp)(this.configuration).registerOutgoingSpidTransactionUsingPOST(body, authorization, subscription, options)(this.fetch, this.basePath);
    }
}
exports.TransferenciasSPIDApi = TransferenciasSPIDApi;
/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
const WebhooksApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Obtiene un webhook registrado en la plataforma mediante su identificador.
         * @summary Consulta de Webhook
         * @param {string} authorization Header para token
         * @param {string} webhook_id Es el identificador del webhook. Ejemplo: wh_54a932866f784b439bc625c0f4e04e12
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(authorization, webhook_id, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getWebhook.');
            }
            // verify required parameter 'webhook_id' is not null or undefined
            if (webhook_id === null || webhook_id === undefined) {
                throw new RequiredError('webhook_id', 'Required parameter webhook_id was null or undefined when calling getWebhook.');
            }
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhook_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista de los webhooks registrados en la plataforma que tengan el estado (estatus)  Activo (ACTIVE) e Inactivo (INACTIVE).
         * @summary Consulta la lista de Webhooks
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(authorization, options = {}) {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra un webhook en la plataforma para su uso como notificador de eventos, cuándo estos ocurran.
         * @summary Alta de Webhook
         * @param {WebhookRequest} body Información para registrar un Webhook
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWebhook(body, authorization, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerWebhook.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling registerWebhook.');
            }
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("WebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WebhooksApiFetchParamCreator = WebhooksApiFetchParamCreator;
/**
 * WebhooksApi - functional programming interface
 * @export
 */
const WebhooksApiFp = function (configuration) {
    return {
        /**
         * Obtiene un webhook registrado en la plataforma mediante su identificador.
         * @summary Consulta de Webhook
         * @param {string} authorization Header para token
         * @param {string} webhook_id Es el identificador del webhook. Ejemplo: wh_54a932866f784b439bc625c0f4e04e12
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(authorization, webhook_id, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).getWebhook(authorization, webhook_id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtiene una lista de los webhooks registrados en la plataforma que tengan el estado (estatus)  Activo (ACTIVE) e Inactivo (INACTIVE).
         * @summary Consulta la lista de Webhooks
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(authorization, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).getWebhooks(authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registra un webhook en la plataforma para su uso como notificador de eventos, cuándo estos ocurran.
         * @summary Alta de Webhook
         * @param {WebhookRequest} body Información para registrar un Webhook
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWebhook(body, authorization, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).registerWebhook(body, authorization, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.WebhooksApiFp = WebhooksApiFp;
/**
 * WebhooksApi - factory interface
 * @export
 */
const WebhooksApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Obtiene un webhook registrado en la plataforma mediante su identificador.
         * @summary Consulta de Webhook
         * @param {string} authorization Header para token
         * @param {string} webhook_id Es el identificador del webhook. Ejemplo: wh_54a932866f784b439bc625c0f4e04e12
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(authorization, webhook_id, options) {
            return (0, exports.WebhooksApiFp)(configuration).getWebhook(authorization, webhook_id, options)(fetch, basePath);
        },
        /**
         * Obtiene una lista de los webhooks registrados en la plataforma que tengan el estado (estatus)  Activo (ACTIVE) e Inactivo (INACTIVE).
         * @summary Consulta la lista de Webhooks
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(authorization, options) {
            return (0, exports.WebhooksApiFp)(configuration).getWebhooks(authorization, options)(fetch, basePath);
        },
        /**
         * Registra un webhook en la plataforma para su uso como notificador de eventos, cuándo estos ocurran.
         * @summary Alta de Webhook
         * @param {WebhookRequest} body Información para registrar un Webhook
         * @param {string} authorization Header para token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWebhook(body, authorization, options) {
            return (0, exports.WebhooksApiFp)(configuration).registerWebhook(body, authorization, options)(fetch, basePath);
        },
    };
};
exports.WebhooksApiFactory = WebhooksApiFactory;
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
class WebhooksApi extends BaseAPI {
    /**
     * Obtiene un webhook registrado en la plataforma mediante su identificador.
     * @summary Consulta de Webhook
     * @param {string} authorization Header para token
     * @param {string} webhook_id Es el identificador del webhook. Ejemplo: wh_54a932866f784b439bc625c0f4e04e12
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhook(authorization, webhook_id, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getWebhook(authorization, webhook_id, options)(this.fetch, this.basePath);
    }
    /**
     * Obtiene una lista de los webhooks registrados en la plataforma que tengan el estado (estatus)  Activo (ACTIVE) e Inactivo (INACTIVE).
     * @summary Consulta la lista de Webhooks
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhooks(authorization, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getWebhooks(authorization, options)(this.fetch, this.basePath);
    }
    /**
     * Registra un webhook en la plataforma para su uso como notificador de eventos, cuándo estos ocurran.
     * @summary Alta de Webhook
     * @param {WebhookRequest} body Información para registrar un Webhook
     * @param {string} authorization Header para token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    registerWebhook(body, authorization, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).registerWebhook(body, authorization, options)(this.fetch, this.basePath);
    }
}
exports.WebhooksApi = WebhooksApi;
